// control-f -> "// Make your own implmentation for your own frontend here" for notes w.r.t making your own rendering frontend
#define STTFONT_STTR_CLASS_SIG(X)															\
	virtual void * sttr_getClassSig() const { return (void*) sttr::getTypeSignature<X>(); } \
	virtual const char * sttr_getClassName() const { return sttr::getTypeName<X>(); }
	
#define STTFONT_STTR_CLASS_SIG_NON_POLY(X)													\
	void * sttr_getClassSig() const { return (void*) sttr::getTypeSignature<X>(); } \
	const char * sttr_getClassName() const { return sttr::getTypeName<X>(); }


#hdr
#warning removeme
struct hb_font_t;

#ifndef STTR_ENABLED
namespace sttr {
	template<typename T> inline const char * getTypeName() { return "sttr_not_defined"; }
	template<typename T> inline char * getTypeSignature() { return (char*) 0; }
	}
#endif

#ifndef SSF_STB_TRUETYPE_INCLUDE_HANDLED
	////////////////////////////////////////
	// STB TRUETYPE 
	// Handle double-including
	#ifdef STB_TRUETYPE_IMPLEMENTATION
		#undef STB_TRUETYPE_IMPLEMENTATION
	#endif
	#include "stb_truetype.h"
	////////////////////////////////////////
#endif

#ifdef SSF_HARFBUZZ_ENABLED
	#ifndef SSF_HARFBUZZ_INCLUDE_HANDLED
		#include "harfbuzz/src/hb.h"
	#endif
	#define SSF_HB_BLOB_TYPE hb_blob_t
	#define SSF_HB_FACE_TYPE hb_face_t
	#define SSF_HB_FONT_TYPE hb_font_t
	#define SSF_HB_BUFFER_TYPE hb_buffer_t	
#else
	#define SSF_HB_BLOB_TYPE int
	#define SSF_HB_FACE_TYPE int
	#define SSF_HB_FONT_TYPE int
	#define SSF_HB_BUFFER_TYPE int
#endif

// Defines
#ifndef SSF_MAP
	#include <map>
	#define SSF_MAP std::map
#endif
#ifndef SSF_VECTOR
	#include <vector>
	#define SSF_VECTOR std::vector
#endif
#ifndef SSF_STRING
	#include <string>
	#define SSF_STRING std::string
#endif
#ifndef SSF_STRING_VIEW
	#include <string_view>
	#define SSF_STRING_VIEW std::string_view
#endif
#ifndef SSF_ATOMIC_INT
	#include <atomic>
	#define SSF_ATOMIC_INT std::atomic<int>
#endif

// new and delete macros
// all calls in this library are done with "foo * f = SSF_NEW(f)"
// implement your custom allocator by defining SSF_NEW and SSF_DEL
#ifndef SSF_NEW
	#define SSF_NEW(X) new X
#endif
#ifndef SSF_NEW_ARR
	#define SSF_NEW_ARR(X,S) new X[S]
#endif
#ifndef SSF_DEL
	#define SSF_DEL(X) delete X
#endif
#ifndef SSF_DEL_ARR
	#define SSF_DEL_ARR(X) delete[] X
#endif

#ifndef SSF_ERROR
	#define SSF_ERROR(X,...) printf(X, ##__VA_ARGS__); abort();
#endif

struct sttfont_uintQuad {
	uint32_t first, second, third, fourth;
	
	inline sttfont_uintQuad() : first(0), second(0), third(0), fourth(0) {}
	inline sttfont_uintQuad(uint32_t a, uint32_t b = 0, uint32_t c = 0, uint32_t d = 0) : first(a), second(b), third(c), fourth(d) {}
	};

// min/max
#define SSF_MIN(X,Y) (X < Y ? X : Y)
#define SSF_MAX(X,Y) (X > Y ? X : Y)

// constants
#define SSF_FONT_IDX_SHIFT 4

// workaround for temp arrays not being a thing on msvc
// used for stack allocated temporary arrays in function or block scope
template <typename T, int S>
struct sttfont_tmpArr {
	T stackBuff[S];
	T* heapBuff;
	T* arr;
	
	inline void reserve(const uint64_t sz) {
		if (heapBuff) abort();
		if (sz > S) {
			heapBuff = SSF_NEW_ARR(T, sz);
			arr = heapBuff;
			}
		}
	inline sttfont_tmpArr() : heapBuff(NULL), arr(&stackBuff[0]) {}
	inline sttfont_tmpArr(const uint64_t sz) : heapBuff(NULL), arr(&stackBuff[0]) { reserve(sz); }
	inline ~sttfont_tmpArr() { if (heapBuff) SSF_DEL_ARR(heapBuff); }
	};
#ifndef SSF_sttfont_tmpArr4096_buffer_size
	#define SSF_sttfont_tmpArr4096_buffer_size 4096
#endif
typedef sttfont_tmpArr<uint8_t,SSF_sttfont_tmpArr4096_buffer_size> sttfont_tmpArr4096;

#include <cstdint>

// move semantics - makes lzz happy
#define SSF_STRING_MS SSF_STRING&&
#define sttfont_formatted_text_item_MS sttfont_formatted_text_item&&
#define sttfont_formatted_text_MS sttfont_formatted_text&&

// misc
#ifdef INT32_MIN
	#define SSF_INT_MIN  INT32_MIN
#else
	#define SSF_INT_MIN 0x8000000;
#endif
struct sttfont_formatted_text;
class sttfont_font_cache;
#end

#src
#include <stdio.h>

#ifndef STB_TRUETYPE_INCLUDE_HANDLED
	////////////////////////////////////////
	// STB TRUETYPE 
	#define STB_TRUETYPE_IMPLEMENTATION
	#include <math.h>
	#include <string.h>
	#include <assert.h>
	#include <stdlib.h>
	#include "stb_truetype.h"
	////////////////////////////////////////
#endif

#ifdef SSF_HARFBUZZ_ENABLED
	#ifndef SSF_HARFBUZZ_IMPL_HANDLED
		#include "harfbuzz/src/harfbuzz.cc"
	#endif
#endif

#end

#insert "sttFontFormattedText.lzz"

struct sttfont_uint32_t_range {
	uint32_t start, end;
	
	static void populateRangesLatin (SSF_VECTOR<sttfont_uint32_t_range> & mRanges) {
		sttfont_uint32_t_range r;
		r.start = 0x20;
		r.end  = 0x7f;
		mRanges.push_back(r);
		} 
	static void populateRangesCyrillic (SSF_VECTOR<sttfont_uint32_t_range> & mRanges) {
		sttfont_uint32_t_range r;
		r.start = 0x0400; r.end  = 0x052F; // Cyrillic + Cyrillic Supplement
		mRanges.push_back(r);
		r.start = 0x2DE0; r.end  = 0x2DFF; // Cyrillic Extended-A
		mRanges.push_back(r);
		r.start = 0xA640; r.end  = 0xA69F; // Cyrillic Extended-B
		mRanges.push_back(r);
		}
	};

struct sttfont_prerendered_text {
	int width, height;
	sttfont_prerendered_text () : width(0), height(0) {}
	
	virtual ~sttfont_prerendered_text() {}
	virtual void freeTexture() {
		// Make your own implmentation for your own frontend here
		// Used to clear any resources held here
		}
	
	/// Draws this prerendered text object, returns the x coordinate
	/// at the end of the drawing
	virtual int draw (const int x, const int y) { return x + width; }
	virtual int drawWithColorMod(const int x, const int y, const uint8_t r, const uint8_t g, const uint8_t b, const uint8_t a = 255) {
		return x + width;
		}
		
	virtual int draw(sttfont_font_cache* fc, const int x, const int y) { return draw(x, y); }
	virtual int drawWithColorMod(sttfont_font_cache* fc, const int x, const int y, const uint8_t r, const uint8_t g, const uint8_t b, const uint8_t a) { return drawWithColorMod(x,y,r,g,b,a); }
		
	};

struct sttfont_glyph {
	int16_t advance, leftSideBearing;
	uint16_t fontIdx, _padding;
	int16_t width, height;
	int16_t xOffset, yOffset;
	
	inline sttfont_glyph () : advance(0), leftSideBearing(0), fontIdx(0), _padding(0), width(0), height(0), xOffset(0), yOffset(0) {}
	};

/// Memory management
struct sttfont_memory {
	char * data;
	uint32_t size;
	bool ownsData;
	
	void alloc(const uint32_t _size) {
		data = SSF_NEW_ARR(char, _size);
		size = _size;
		ownsData = true;
		}
		
	void transferTo(sttfont_memory & destination) {
		destination.data = data;
		destination.size = size;
		destination.ownsData = ownsData;
		ownsData = false;
		}
		
	void cloneTo(sttfont_memory& other) {
		other.alloc(size);
		memcpy(other.data, data, size);
		other.ownsData = true;
		}
	
	sttfont_memory () : data(NULL), size(0), ownsData(false) {}
	~sttfont_memory () {
		if (ownsData) {
			SSF_DEL_ARR(data);
			data = NULL;
			}
		}
	};
	
/// Linked list of fonts. This is for font fallback purposes
struct sttfont_font_list {
	stbtt_fontinfo mFont;
	sttfont_memory mMemory;
	uint8_t format;			// Value is one of sttfont_format::FORMAT_*
	SSF_VECTOR<sttfont_font_list*> mFormatedVariants;	// Variants for bold, italic, etc
	sttfont_font_list * next;
	
	SSF_HB_BLOB_TYPE* hbFontBlob;
	SSF_HB_FACE_TYPE* hbFace;
	SSF_HB_FONT_TYPE* hbFont;
		
	sttfont_font_list() : format(0), next(NULL), hbFontBlob(NULL), hbFace(NULL), hbFont(NULL) {
		}
	~sttfont_font_list() {
		#ifdef SSF_HARFBUZZ_ENABLED
		if (hbFont) {
			hb_font_destroy(hbFont);
			hbFont = NULL;
			}
		if (hbFace) {
			hb_face_destroy(hbFace);
			hbFace = NULL;
			}
		if (hbFontBlob) {
			hb_blob_destroy (hbFontBlob);
			hbFontBlob = NULL;
			}
		#endif
		for (sttfont_font_list * fl : mFormatedVariants)
			delete fl;
		if (next) delete next;
		}
		
	
	sttfont_font_list* getSubFont(const uint16_t idx) {
		uint16_t idxw = idx;
		
		sttfont_font_list* working = this;
		while (working) {
			if (idxw == 0) return working;
			idxw--;
			if (idxw < mFormatedVariants.size())
				return mFormatedVariants[idxw];
			idxw -= mFormatedVariants.size();
			working = working->next;
			}
		return this;
		
		}

	/// Returns non-zero if this.mFont contains the codepoint
	int hasCodepoint (const uint32_t codepoint) const {
		return stbtt_FindGlyphIndex(&mFont, codepoint);
		}
	
	/// Finds the font with the codepoint for the specified format (bold, italic, etc) 
	void fetchFontForCodepoint(const uint32_t codepoint, const uint8_t format, stbtt_fontinfo ** mFontOut, int * indexOut, uint16_t * fontIdxOut) {
		sttfont_font_list * working = this;
		
		*mFontOut = NULL;
		*indexOut = 0;
		*fontIdxOut = 0;
		
		uint16_t fontIdxWorking = 0;
		
		while (working) {
			int index = stbtt_FindGlyphIndex(&(working->mFont), codepoint);
			if (index) {
				// Check for format in the variants
				if (format) {
					int bestBitsCount = 0;
					sttfont_font_list * bestMatch = NULL;
					sttfont_font_list * bestMatch2 = NULL;
					uint16_t bestIdx = -1;
					uint16_t bestIdx2 = -1;
					uint16_t sz = mFormatedVariants.size();
					sttfont_font_list** d = mFormatedVariants.data();
					for (uint16_t i = 0; i < sz; ++i) {
						sttfont_font_list * f = d[i];
						uint8_t mask = (format & f->format);
						if (mask) {
							int nBits = 0;
							#if defined(_MSC_VER)
								nBits = __popcnt(mask);
							#elseif defined(__GNUC__) || defined(__clang__)
								nBits = __builtin_popcount(mask);
							#else
								for (int i2 = 0; i2 < 7; ++i2)
									if (mask & (1 << i2)) nBits++;
							#endif
							if (nBits > bestBitsCount) {
								bestBitsCount = nBits;
								bestMatch2 = bestMatch;
								bestIdx2 = bestIdx;
								bestMatch = f;
								bestIdx = i;
								}
							}
						}
					
					if (bestMatch) {
						int index2 = stbtt_FindGlyphIndex(&(bestMatch->mFont), codepoint);
						*mFontOut = &(bestMatch->mFont);
						*indexOut = index2;
						*fontIdxOut = (fontIdxWorking << SSF_FONT_IDX_SHIFT) | (bestIdx+1);
						return;
						}
					if (bestMatch2) {
						int index2 = stbtt_FindGlyphIndex(&(bestMatch2->mFont), codepoint);
						*mFontOut = &(bestMatch2->mFont);
						*indexOut = index2;
						*fontIdxOut = (fontIdxWorking << SSF_FONT_IDX_SHIFT) | (bestIdx2+1);
						return;
						}
					}
				
				// Format not found/no format
				*mFontOut = &(working->mFont);
				*indexOut = index;
				*fontIdxOut = fontIdxWorking << SSF_FONT_IDX_SHIFT;
				return;
				}
			fontIdxWorking++;
			working = working->next;
			}
		}
	};

struct sttfont_utf8 {
	static int utf8_charsize(const char* c) {
		if (!c) return 0;
		if ((uint8_t)*c <= 0x7F) return 1;
		else if ((uint8_t)*c <= 0xDF) return 2;
		else if ((uint8_t)*c <= 0xEF) return 3;
		else if ((uint8_t)*c <= 0xF7) return 4;
		else
			return 4;
		}
	
	static int utf8_charsize_from_codepoint(const uint32_t codepoint) {
		if (codepoint <= 0x7F)        return 1; 
		else if (codepoint <= 0x7FF)  return 2; 
		else if (codepoint <= 0xFFFF) return 3;
		return 4;
		}
		
	static int utf8_encode(const uint32_t codepoint, char *buf) {
		if (codepoint <= 0x7F) {
			buf[0] = (char)codepoint;
			buf[1] = '\0';
			return 1;
			}
		else if (codepoint <= 0x7FF) {
			buf[0] = (char)(0xC0 | (codepoint >> 6));
			buf[1] = (char)(0x80 | (codepoint & 0x3F));
			buf[2] = '\0';
			return 2;
			}
		else if (codepoint <= 0xFFFF) {
			buf[0] = (char)(0xE0 | (codepoint >> 12));
			buf[1] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
			buf[2] = (char)(0x80 | (codepoint & 0x3F));
			buf[3] = '\0';
			return 3;
			}
		else if (codepoint <= 0x10FFFF) {
			buf[0] = (char)(0xF0 | (codepoint >> 18));
			buf[1] = (char)(0x80 | ((codepoint >> 12) & 0x3F));
			buf[2] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
			buf[3] = (char)(0x80 | (codepoint & 0x3F));
			buf[4] = '\0';
			return 4;
			}
		else {
			buf[0] = '\0';
			return 0;
			}
		}
	
	/// Reads a utf8 codepoint from a string
	/// c is &string[seek]
	static uint32_t utf8_read(const char* c, uint32_t & seek, const uint32_t maxLen) {
		if (!c) return 0;
		int chsz = utf8_charsize(c);
		seek += chsz;
	
		if (seek > maxLen) {
			return *c; //Buffer overflow - stop to be safe!
			}
			
		if (chsz == 1) return *c;		
		if (chsz == 2)
			return (((uint32_t((uint8_t) c[0] & 0b00111111) << 6)) | uint32_t((uint8_t) c[1] & 0b00111111));
		if (chsz == 3)
			return (uint32_t((uint8_t) c[0] & 0b00011111) << 12) | (uint32_t((uint8_t) c[1] & 0b00111111) << 6) | uint32_t((uint8_t) c[2] & 0b00111111);
		return (uint32_t((uint8_t) c[0] & 0b00001111) << 18) | (uint32_t((uint8_t) c[1] & 0b00111111) << 12) | (uint32_t((uint8_t) c[2] & 0b00111111) << 6) | uint32_t((uint8_t) c[3] & 0b00111111);
		}
	
	};

/// Cache of a font
class sttfont_font_cache {
public:
	sttfont_font_list mFont;
	// Read-only (for you!) parameters set by library. You can change these
	// if you know what you're doing
	int ascent;
	int descent;
	int lineGap;
	int baseline;
	int rowSize;
	int tabWidth;	// May be changed later
	float scale;
	float underlineThickness;
	float strikethroughThickness;
	float underlinePosition;
	float strikethroughPosition;
	// Must be set before loadFont() is called. Cannot be changed after
	int faceSize;			// Default is 20. All the parameters are calcualted based on this
	int tabWidthInSpaces;	// Default is 8, set this before loadFont(). Max 128. Sets tabWidth when font is loaded
	void* userData;			// Pointer for whatever purpose you see fit

	// Harfbuzz stuff
	SSF_HB_BUFFER_TYPE* hbShapingScratchpad;
	SSF_MAP<uint64_t,uint16_t> hbFontLookup;
	uint32_t hbUnicodeReplacementCodeGlyphIndex;	// For the first font loaded, what is the 0xFFFD character?
	uint32_t hbQuestionMarkGlyphIndex;				// For the first font loaded, what is the '?' character?
	float hbScaleFactor;							// Converts hb coordinates to this coordinate system
	bool ownsHbShapingScratchPad;
	
	sttfont_font_cache () : ascent(0), descent(0), lineGap(0), baseline(0), rowSize(0), tabWidth(1), scale(1.f),
		underlineThickness(1.0), strikethroughThickness(1.0), underlinePosition(0.0), strikethroughPosition(0.0),
		faceSize(20), tabWidthInSpaces(8), userData(NULL)
		, hbShapingScratchpad(NULL), hbUnicodeReplacementCodeGlyphIndex(0), hbQuestionMarkGlyphIndex(0), hbScaleFactor(1.0f), ownsHbShapingScratchPad(false)
		{}
	
	virtual ~sttfont_font_cache () {
		#ifdef SSF_HARFBUZZ_ENABLED
			if (hbShapingScratchpad && ownsHbShapingScratchPad) {
				hb_buffer_destroy(hbShapingScratchpad);
				}
		#endif
		}
	
		
	/// Sets the face size. Must be called BEFORE loading a font!
	void setFaceSize(const int _faceSize) { faceSize = _faceSize; }
	
	/// The size between rows, in the same coordinates as whatever you set faceSize as
	int getScaledRowSize () const { return scale * rowSize; }
	
	/// Used by producer_consumer_font_cache to sync internal states
	void syncFrom(const sttfont_font_cache & other) {
		tabWidth = other.tabWidth;
		faceSize = other.faceSize;
		tabWidthInSpaces = other.tabWidthInSpaces;
		}
	
	/// Loads the primary font
	/// Also computes font properties (ascent/decent/basline/scale/rowSize/etc)
	/// ttf_buffer must be null terminated
	///
	/// If you are using harfbuzz the internal scratchpad for shaping will be created here
	void loadFont (const char * ttf_buffer, const size_t ttf_buffer_len, int index = 0) {
		sttfont_font_cache::loadFontCommonWorker(mFont, ttf_buffer, ttf_buffer_len, index);
		
		stbtt_GetFontVMetrics(&mFont.mFont, &ascent, &descent, &lineGap);
		scale = stbtt_ScaleForPixelHeight(&mFont.mFont, faceSize);
		baseline = ascent*scale;
		rowSize = ascent - descent + lineGap;
		
		strikethroughThickness = faceSize/20.0f;
		if (strikethroughThickness < 1) strikethroughThickness = 1;
		strikethroughPosition = baseline * 0.75f - strikethroughThickness/2.0f;
		underlineThickness = strikethroughThickness;
		underlinePosition = baseline + underlineThickness;
			
		#ifdef SSF_HARFBUZZ_ENABLED
			if (!hbShapingScratchpad)
				generateHbScratchpad();
			
			hbUnicodeReplacementCodeGlyphIndex = stbtt_FindGlyphIndex(&mFont.mFont, 0xFFFD);
			hbQuestionMarkGlyphIndex = stbtt_FindGlyphIndex(&mFont.mFont, (uint32_t) '?');
			hbScaleFactor = scale;
		#endif
		
		int w,h;
		getTextSize(w,h,"                                                                                                                                ", tabWidthInSpaces <= 128 ? tabWidthInSpaces : 128);
		tabWidth = w;
		if (tabWidth < 1) tabWidth = 1;
		}
	
	/// Sets a scratchpad buffer for harfbuzz shaping
	/// Pass NULL to release the scratchpad
	void setHbScrachpad(SSF_HB_BUFFER_TYPE* buffer) {
		#ifdef SSF_HARFBUZZ_ENABLED
		if (hbShapingScratchpad && ownsHbShapingScratchPad) {
			hb_buffer_destroy(hbShapingScratchpad);
			}
		hbShapingScratchpad = buffer;
		ownsHbShapingScratchPad = false;
		#endif
		}
	
	/// Manually generates an internal scratchpad for harfbuzz shaping
	void generateHbScratchpad() {
		#ifdef SSF_HARFBUZZ_ENABLED
		if (hbShapingScratchpad && ownsHbShapingScratchPad) {
			hb_buffer_destroy(hbShapingScratchpad);
			}
		hbShapingScratchpad = hb_buffer_create();
		ownsHbShapingScratchPad = true;
		#endif
		}
	
protected:
	static void loadFontCommonWorker(sttfont_font_list& target,  const char * ttf_buffer, const size_t ttf_buffer_len, int index) {
		// used by loadFont, addFont
		const int offset = stbtt_GetFontOffsetForIndex((const unsigned char *) ttf_buffer, index);
		stbtt_InitFont(&target.mFont, (const unsigned char *) ttf_buffer, offset);
	
		#ifdef SSF_HARFBUZZ_ENABLED
			target.hbFontBlob = hb_blob_create(ttf_buffer, ttf_buffer_len, HB_MEMORY_MODE_READONLY, NULL, NULL);
			
    printf("blob: %i (len: %i), index %i\n", hb_blob_get_length(target.hbFontBlob), ttf_buffer_len, index );
    
			target.hbFace = hb_face_create(target.hbFontBlob, index);
			target.hbFont = hb_font_create(target.hbFace);
			
			
		#endif
		}
	
public:
	/// Does the dame as loadFont, but transfers ownership of the memory to here
	/// ttf_buffer must be null terminated
	/// ttf_buffer will be deallocated when this class is destroyed
	/// Example usage:
	/// filep * file = openFile("path/to/file");
	/// sttfont_memory mem;
	/// mem.alloc(file_size);
	/// fread(file, &mem.data);
	/// mSdl_stb_font_cache.loadFontManaged (mem);
	/// You can safely let mem drop out of scope
	void loadFontManaged (sttfont_memory & memory, int index = 0) {
		memory.transferTo(mFont.mMemory);
		loadFont(mFont.mMemory.data, mFont.mMemory.size, index);
		}
		
	/// Loads a fallback font. If a glyph is not found in a primary font it'll fallback to one of these
	/// ttf_buffer must be null terminated
	void addFont (const char * ttf_buffer, const size_t ttf_buffer_len, int index = 0) {
		addFontWrap afw(ttf_buffer, ttf_buffer_len);
		afw.index = index;
		addFont_worker(afw, false);
		}
		
	/// Same as addFont, but transfers ownership of the memory to here
	/// ttf_buffer will be deallocated when this class is destroyed
	/// ttf_buffer must be null terminated
	/// Example usage:
	/// filep * file = openFile("path/to/file");
	/// sttfont_memory mem;
	/// mem.alloc(file_size);
	/// fread(file, &mem.data);
	/// mSdl_stb_font_cache.loadFontManaged (mem);
	/// You can safely let mem drop out of scope
	void addFontManaged (sttfont_memory & memory, int index = 0) {
		addFontWrap afw(NULL, 0);
		afw.memory = &memory;
		afw.index = index;
		addFont_worker(afw, false);
		}
	
	/// Adds a format variant to the last loaded font
	/// Use this to add Bold, Italic, etc
	/// FormatMask is one of sttfont_format::FORMAT_*
	void addFormatFont (uint8_t formatMask, const char * ttf_buffer, const size_t ttf_buffer_len, int index = 0) {
		addFontWrap afw(ttf_buffer, ttf_buffer_len);
		afw.index = index;
		addFont_worker(afw, true, formatMask);
		}
	
	void addFormatFontManaged (uint8_t formatMask, sttfont_memory & memory, int index = 0) {
		addFontWrap afw(NULL, 0);
		afw.memory = &memory;
		afw.index = index;
		addFont_worker(afw, true, formatMask);
		}
		
		
protected:
	struct addFontWrap {
		const char * ttf_buffer;
		size_t ttf_buffer_len;
		sttfont_memory * memory;
		int index;
		addFontWrap (const char * c, const size_t _len) : ttf_buffer(c), ttf_buffer_len(_len), memory(NULL), index(0) {}
		};
		
	void addFont_worker(addFontWrap & fwm, bool isFormatVariant, uint8_t formatMask = 0) { 
		sttfont_font_list * n = SSF_NEW(sttfont_font_list);
		sttfont_font_list * w = &mFont;
		while (w->next)
			w = w->next;
		n->format = formatMask;
		
		if (fwm.memory) {
			sttfont_memory & memory = *(fwm.memory);
			memory.transferTo(n->mMemory);
			sttfont_font_cache::loadFontCommonWorker(*n, (const char *) n->mMemory.data, n->mMemory.size, fwm.index);
			}
		else {
			sttfont_font_cache::loadFontCommonWorker(*n, (const char *) fwm.ttf_buffer, fwm.ttf_buffer_len, fwm.index);
			}
		if (isFormatVariant) {
			w->mFormatedVariants.push_back(n);
			if (w->mFormatedVariants.size() >= (1 << SSF_FONT_IDX_SHIFT)) {
				SSF_ERROR("Too many subfonts");
				}
			}
		else
			w->next = n;
		}
public:

	/// For a given codepoint, generate a texture (if required) and populate the
	/// details of the glyph (width, height, etc) in gOut	
	/// if bitmapOut is set then the bitmap data will by copied there and the glyph not stored, you must store it yourself
	void genGlyph (const uint32_t codepoint, const uint8_t format, uint16_t fontIdx, uint32_t intIdx, sttfont_glyph * gOut, unsigned char ** bitmapOut = NULL) {
		// Fetch font and index - existance check for glyph in font
		// format is a number representing regular, bold, itallic, bold itallic
		stbtt_fontinfo * mFontContaining = NULL;
		
		if (codepoint != 0) {
			// Lookup font and index for codepoint
			int mIndex;
			mFont.fetchFontForCodepoint(codepoint, format, &mFontContaining, &mIndex, &fontIdx);
	   	printf("genGlyph lookup %#04x %i %i \n", codepoint, fontIdx, intIdx);
			if (!mIndex)
				return;
			intIdx = mIndex;
			}
		else {
			#warning todo - cache last font lookup here
			sttfont_font_list* l = findSubfontByIndex(fontIdx);
			if (l)
				mFontContaining = &l->mFont;
			}
			
		if (!mFontContaining) abort();
		
		// found the font! generate the glyph
	   	int w,h,woff,hoff;
	   	int x0,x1,y0,y1;
	   	
	   	
	   	if (codepoint == 0)
			stbtt_GetGlyphBitmapBox(mFontContaining, intIdx, scale, scale, &x0, &y0, &x1, &y1);
	   	else
			stbtt_GetCodepointBitmapBox(mFontContaining, codepoint, scale, scale, &x0, &y0, &x1, &y1);
	   	w = x1-x0;
	   	h = y1-y0;
	   	woff = x0;
	   	hoff = y0;
	   	
		unsigned int sz = w*h;
	   	
	   	printf("genGlyph %#04x %i %i, sz %i, w %i, h %i \n", codepoint, fontIdx, intIdx, sz, w, h);
		if (sz) {
			sttfont_tmpArr4096 bitmapStore(sz);
			unsigned char* bitmap = (unsigned char*) bitmapStore.arr;
			
			if (codepoint == 0)
				stbtt_MakeGlyphBitmap(mFontContaining, bitmap, w, h, w, scale, scale, intIdx);
			else
				stbtt_MakeCodepointBitmap(mFontContaining, bitmap, w, h, w, scale, scale, codepoint);
			
			// Convert bitmap to RGBA8888
			// Todo - change RBGA8888 to R8
			if (bitmapOut) {
				//memcpy, the frontend will bulk store glyphs
				(*bitmapOut) = SSF_NEW_ARR(unsigned char,sz*4);
				unsigned char* bitmap2 = *bitmapOut;

				for (unsigned int i = 0; i < sz; ++i) {
					bitmap2[i*4+0] = 255;
					bitmap2[i*4+1] = 255;
					bitmap2[i*4+2] = 255;
					bitmap2[i*4+3] = bitmap[i];
					}
				}
			else {
				// wirte single character directly
				sttfont_tmpArr4096 bitmapStore2(sz * 4);
				unsigned char* bitmap2 = (unsigned char*) bitmapStore2.arr;
				
				for (unsigned int i = 0; i < sz; ++i) {
					bitmap2[i*4+0] = 255;
					bitmap2[i*4+1] = 255;
					bitmap2[i*4+2] = 255;
					bitmap2[i*4+3] = bitmap[i];
					}
				genGlyph_writeData(codepoint, fontIdx, intIdx, gOut, bitmap2, w, h);
				}
		}
		
		gOut->width = w;
		gOut->height = h;
		int advance, leftSideBearing;
		if (codepoint == 0)
			stbtt_GetGlyphHMetrics(mFontContaining, intIdx, &advance, &leftSideBearing);
		else
			stbtt_GetCodepointHMetrics(mFontContaining, codepoint, &advance, &leftSideBearing);
		
		if (abs(advance) >= 0x7fff || abs(leftSideBearing) >= 0x7fff) {
			SSF_ERROR("Invalid glyph metrics! Advance: %i, leftSideBearing %i", advance, leftSideBearing );
			}
		gOut->advance = advance;
		gOut->leftSideBearing = leftSideBearing;
		gOut->fontIdx = fontIdx;
		
		gOut->xOffset = woff;
		gOut->yOffset = hoff;
		}
	
	/// Pregenerate glyphs. For SDL software rendering this isn't needed
	/// For GPU based rendering that uses a atlas (OpenGl, Bgfx, etc) this is recommended
	virtual void pregenGlyphs(SSF_VECTOR<sttfont_uint32_t_range> & mRanges, const uint8_t format) {
		// Make your own implmentation for your own frontend here
		for (const sttfont_uint32_t_range & r : mRanges) {
			for (uint32_t codepoint = r.start; codepoint <= r.end; ++codepoint) {
				uint64_t target = getGlyphKey(codepoint, format, 0, 0);
				genGlyph_createAndInsert(target, codepoint, format, 0, 0);
				}
			}
		}
	
	virtual void genGlyph_writeData (const uint32_t codepoint, const uint16_t fontIdx, const uint32_t intIdx, sttfont_glyph * gOut, unsigned char * bitmap2, int w, int h) {
		// Make your own implmentation for your own frontend here
		// If codepoint == 0, then use fontIdx and fontGlypthIdx to encode your key
		// note that fontIdx and intIdx will be set here regardless if you are using codepoint mode or not
		abort();
		}
	
	virtual sttfont_glyph * getGlyph(const uint64_t target) {
		// Make your own implmentation for your own frontend here
		abort();
		return NULL;
		}
	
	// Provides a key to look-up a glyph. Can be used in CODEPOINT mode or HARFBUZZ mode
	// Codepoint mode -> fontIdx = 0, intIdx = 0
	// Harfbuzz mode -> codepoint = 0 
	inline static uint64_t getGlyphKey(const uint32_t codepoint, const uint8_t format, const uint16_t fontIdx, const uint32_t intIdx) {
		if (codepoint) {
			if (fontIdx || intIdx)
				abort(); // invalid lookup
			}
		return codepoint | (uint64_t(format) << 48) | (uint64_t(fontIdx) << 32) | intIdx;
		}
	
	/// Looks up a glyph, generating it if it does not exist yet
	sttfont_glyph * getGenGlyph(const uint32_t codepoint, const uint8_t format, const uint16_t fontIdx, const uint32_t intIdx) {
		const uint64_t target = getGlyphKey(codepoint, format, fontIdx, intIdx);
		sttfont_glyph * r = getGlyph(target);
		if (r) return r;
		return genGlyph_createAndInsert(target, codepoint, format, fontIdx, intIdx);
		}
		
	virtual sttfont_glyph * genGlyph_createAndInsert(const uint64_t target, const uint32_t codepoint, const uint8_t format, const uint16_t fontIdx, const uint32_t intIdx) {
		// Make your own implmentation for your own frontend here
		// Codepoint mode -> fontIdx = 0, intIdx = 0
		// Harfbuzz mode -> codepoint = 0 
		abort();
		return NULL;
		}
	
	struct findSubfontLookupHint {
		// used to cache the result of findSubfontByIndex(...) to prevent
		// redundant lookups in a look
		uint16_t fontIdx;
		sttfont_font_list * font;
		
		uint16_t lastFontIdx;
		sttfont_font_list * lastFont;
		
		inline findSubfontLookupHint() : fontIdx(-1), font(NULL), lastFontIdx(-1), lastFont(NULL) {}
		};
		
	void findSubfontByIndexWHint(const uint16_t fontIdx, findSubfontLookupHint& mHint) {
		// Checks if re-lookup is required. Result is stored in hint structure
		if (fontIdx != mHint.fontIdx) {
			if (fontIdx == mHint.lastFontIdx) {
				// swap
				printf("findSubfontByIndexWHint - SWAP!\n");
				uint16_t fiTemp = mHint.fontIdx;
				sttfont_font_list * fpTemp = mHint.font;
				mHint.fontIdx = mHint.lastFontIdx;
				mHint.font = mHint.lastFont;
				mHint.lastFontIdx = fiTemp;
				mHint.lastFont = fpTemp;
				return;
				}
			mHint.lastFontIdx = mHint.fontIdx;
			mHint.lastFont = mHint.font;
			mHint.font = findSubfontByIndex(fontIdx);
			mHint.fontIdx = fontIdx;
			}
		}
	
	sttfont_font_list* findSubfontByIndex(const uint16_t fontIdx) {
		uint16_t depth = fontIdx >> SSF_FONT_IDX_SHIFT;
		uint16_t formatIdx = fontIdx & ((uint16_t(1) << SSF_FONT_IDX_SHIFT) - 1);
		
		uint16_t currentDepth = 0;
		sttfont_font_list * w = &mFont;
		while (currentDepth < depth) {
			w = w->next;
			currentDepth++;
			}
		
		printf("findSubfontByIndex %#04x, %i %i\n", w, formatIdx,  w ? w->mFormatedVariants.size() : -1);
		
		if (formatIdx) {
			if (formatIdx-1 < w->mFormatedVariants.size())
				return w->mFormatedVariants[formatIdx-1];
			}
		return w;
		}
	
	int getKerningAdvance(const sttfont_glyph* G1, const sttfont_glyph* G2, const uint32_t cp1, const uint32_t cp2, findSubfontLookupHint& mHint) {
		if ((!G1) || (!G2)) return 0;
		if (G1->fontIdx != G2->fontIdx) return 0;
		findSubfontByIndexWHint(G1->fontIdx, mHint);
		return stbtt_GetCodepointKernAdvance(&(mHint.font->mFont), cp1, cp2);
		}	
	
	/// Draws a c string at position x, y
	/// maxLen should be set if you want to use non-zero terminated strings
	/// Returns the x coordinate of the caret at the end of the string
	/// (If you draw a 100 width string at x=5 this will return 105.
	/// If there is a newline at the end this will return 5) 
	int drawText(const int x, const int y, const char * c, const uint32_t maxLen = -1) {
		return processString(x, y, c, maxLen, NULL, true);
		}
	
	int drawText (const int x, const int y, const SSF_STRING & str) {
		return drawText(x,y,str.data(),str.size());
		}
	
	/// With formatting for the entire string
	int drawText(const int x, const int y, const sttfont_format format, const char * c, const uint32_t maxLen = -1) {
		return processString(x, y, c, maxLen, &format, true);
		}
	
	int drawText (const int x, const int y, const sttfont_format format, const SSF_STRING & str) {
		return drawText(x,y,format, str.data(),str.size());
		}

	/// These overloads return the width and height of the drawn string
	int drawText(const int x, const int y, int & widthOut, int & heightOut, const char * c, const uint32_t maxLen = -1) {
		return processString(x, y, c, maxLen, NULL, true, &widthOut, &heightOut);
		}
	
	int drawText (const int x, const int y, const sttfont_format format, const SSF_STRING & str, int & widthOut, int & heightOut) {
		return drawText(x,y,widthOut, heightOut, format, str.data(),str.size());
		}
		
	int drawText(const int x, const int y, int & widthOut, int & heightOut, const sttfont_format format, const char * c, const uint32_t maxLen = -1) {
		return processString(x, y, c, maxLen, &format, true, &widthOut, &heightOut);
		}
	
	int drawText (const int x, const int y, const SSF_STRING & str, int & widthOut, int & heightOut) {
		return drawText(x,y,widthOut, heightOut, str.data(),str.size());
		}
		
	int drawText(const int x, const int y, const sttfont_formatted_text & text) {
		int dummyWidth, dummyHeight;
		return drawText(x, y, text, dummyWidth, dummyHeight);
		}
		
	int drawText(const int x, const int y, const sttfont_formatted_text & text, int & widthOut, int & heightOut) {
		return processFormatted(text, x, y, true, &widthOut, &heightOut);
		}
	
	/// Gets the size of a string (width and height). Returns the x position of the caret at the end of the string
	int getTextSize (int & w, int & h, const char * c, const uint32_t maxLen = -1, sttfont_lookupHint * mHint = NULL, const int * const maxWidth = NULL) {
		return processString(0, 0, c, maxLen, NULL, false, &w, &h, maxWidth);
		}
		
	int getTextSize (int & w, int & h, const SSF_STRING & str, sttfont_lookupHint * mHint = NULL, const int * const maxWidth = NULL) {
		return processString(0, 0, str.data(), str.size(), NULL, false, &w, &h, maxWidth, mHint);
		}
	int getTextSize (int & w, int & h, const sttfont_formatted_text & str, sttfont_lookupHint * mHint = NULL, const int * const maxWidth = NULL) {
		return processFormatted(str, 0, 0, false, &w, &h, maxWidth, mHint);
		}
	
	/// Counts the number of newlines ('\n') a string has. Utf8-safe
	int countNewlines(const SSF_STRING & str) {
		int n = 0;
		
		uint32_t seek = 0;
		const uint32_t len = str.length();
		while (seek < len) {
			uint32_t uChar = sttfont_utf8::utf8_read(&str[seek], seek, len);
			if (uChar == uint32_t('\n')) n++;
			}
		return n;
		}
	
	/// Returns the number of rows (newlines + 1) a string has here
	int getNumberOfRows (const SSF_STRING & str) {
		int n = 1 + countNewlines(str);
		return n;
		}
		
	int getNumberOfRows (const sttfont_formatted_text & str) {
		int n = 1;
		for (const sttfont_formatted_text_item & item : str.mItems) {
			n += countNewlines(item.text);
			}
		return n;
		}

	/// Returns the height of string. This is much faster than getTextSize(), but only returns the height
	int getTextHeight (const SSF_STRING & str) {
		return scale*rowSize*getNumberOfRows(str);
		}
	int getTextHeight (const sttfont_formatted_text & str) {
		return scale*rowSize*getNumberOfRows(str);
		}
	
	/// Returns the rendered width of a string. This is just a wrapper for getTextSize() that discards the height
	int getTextWidth(const SSF_STRING & str, sttfont_lookupHint * mHint = NULL, const int * const maxWidth = NULL) {
		int w,h;
		getTextSize(w, h, str, mHint, maxWidth);
		return w;
		}
		
	int getTextWidth(const sttfont_formatted_text & str, sttfont_lookupHint * mHint = NULL, const int * const maxWidth = NULL) {
		int w,h;
		getTextSize(w, h, str, mHint, maxWidth);
		return w;
		}
	
	virtual void onStartDrawing() {}
	virtual void onCompletedDrawing() {}
	virtual void startManuallyBuffering(const bool beginBuffering) {}
	virtual void endManuallyBuffering(const bool flush) {}
	
	int processString (const int x, const int y, const char* c, const uint32_t maxLen, const sttfont_format * const format, const bool isDrawing, int * const widthOut = NULL, int * const heightOut = NULL, const int * const maxWidth = NULL, sttfont_lookupHint * mHint = NULL, const int * const threshX = NULL, const int * const threshY = NULL, int * const caretPosition = NULL, int initialXOffset = 0) {
		onStartDrawing();
		int r = processString_worker(x, y, c, maxLen, format, isDrawing, widthOut, heightOut, maxWidth, mHint, threshX, threshY, caretPosition, initialXOffset);
		onCompletedDrawing();
		return r;
		}

protected:
	/// Finds the first fontIdx containing codepoint
	/// Does a quick lookup of the hbFontLookup map first
	uint16_t hbFindFontForCodepoint (const uint32_t codepoint, const uint8_t formatCode) {
		const uint64_t target = getGlyphKey(codepoint, formatCode, 0, 0);
	
		auto it = hbFontLookup.find(target);
		uint16_t gFontIdx = -1;
		if (it == hbFontLookup.end()) {
			// glyph not found. Find it and generate a mapping 
			uint16_t fontIdx2;
			int index2;
			stbtt_fontinfo* mFont2;
			mFont.fetchFontForCodepoint(codepoint, formatCode, &mFont2, &index2, &fontIdx2);
			if (fontIdx2 != uint16_t(-1)) {
				hbFontLookup[target] = fontIdx2;
				gFontIdx = fontIdx2; 
				}
			}
		else {
			gFontIdx = it->second;
			}
		return gFontIdx;
		}
	
	int processHarfbuzzChunk(const char* c, uint32_t maxLen, const int x0, int& xx, int& yy, const sttfont_format * const format, const bool isDrawing, const uint32_t chunkStart, const uint32_t chunkEnd, const uint16_t fontIdx, findSubfontLookupHint & fontLookupHint, int & overdraw, const int * maxWidth, const bool isLTR) {
		#ifdef SSF_HARFBUZZ_ENABLED
			findSubfontByIndexWHint(fontIdx, fontLookupHint);
			printf("findSubfontByIndexWHint %i %#04x\n", fontIdx, fontLookupHint.font);
			if (!fontLookupHint.font) return xx; // no valid font (this should never be true)
			
			// shaping note: harfbuzz wants to read a few characters a bit before and after to get "context"
			// But if the font changes then the context does not matter
			if (!hbShapingScratchpad) {
				SSF_ERROR("No harfbuzz scratchpad");
				}
			
			hb_buffer_reset(hbShapingScratchpad);
   
			hb_buffer_add_utf8(hbShapingScratchpad, c, maxLen, chunkStart, chunkEnd-chunkStart);
			hb_buffer_guess_segment_properties(hbShapingScratchpad); 
			hb_shape(fontLookupHint.font->hbFont, hbShapingScratchpad, NULL, 0);
			
			unsigned int glyph_count;
			hb_glyph_info_t *glyph_info    = hb_buffer_get_glyph_infos(hbShapingScratchpad, &glyph_count);
			hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hbShapingScratchpad, &glyph_count);
			
			printf("glyph count %i (%i), fontIdx: %i, isLTR: %b, hb_font: %x, string: [%.*s], \n", int(glyph_count), chunkEnd-chunkStart, fontIdx, isLTR, fontLookupHint.font->hbFont, chunkEnd-chunkStart, &c[chunkStart]);
			
			hb_position_t cursor_x = 0;
			hb_position_t cursor_y = 0;
			
			for (unsigned int i = 0; i < glyph_count; i++) {
				const uint32_t cluster = glyph_info[i].cluster;
				hb_codepoint_t glyphid  = glyph_info[i].codepoint;
				hb_position_t x_offset  = glyph_pos[i].x_offset;
				hb_position_t y_offset  = glyph_pos[i].y_offset;
				hb_position_t x_advance = glyph_pos[i].x_advance;
				hb_position_t y_advance = glyph_pos[i].y_advance;
				
				//char cbuff[5];
				//sttfont_utf8::utf8_encode(glyphid, &cbuff[0]);
				//printf("(%#04x, %s) ", glyphid, cbuff);
				
				if (maxWidth) {
					if (xx > *maxWidth) break;
					}
					
				if (c[cluster] == '\t') {
					// Tab
					printf("Tab %i %i!\n", ((xx - x0)/tabWidth), x0 + (int((xx - x0)/tabWidth)+1)*tabWidth );
					int nTabsSoFar = (xx - x0)/tabWidth;
					xx = x0 + (nTabsSoFar+1)*tabWidth;
					continue;
					}
				
				uint8_t formatCode = 0;
				if (format)
					formatCode = format->format;
				if (glyphid == 0) {
					// We have to look up the glyph directly
					uint32_t cluster2 = cluster;
					uint32_t codepoint = sttfont_utf8::utf8_read(c + cluster2, cluster2, maxLen);
					
					printf("missing glypth %i %#04x [%c] %#04x [%c]\n", cluster - chunkStart, codepoint, codepoint, c[cluster], c[cluster]);
					uint16_t newFontIdx = hbFindFontForCodepoint(codepoint, formatCode);
					printf( " new font idx %i\n", newFontIdx ); 
					if (newFontIdx == (uint16_t(-1)))
						continue;
					
					// convert code point to glyph idx
					findSubfontByIndexWHint(newFontIdx, fontLookupHint);
					printf( " new font %#04x\n", fontLookupHint.font );
					if (!fontLookupHint.font)
						continue;
					
					int index2 = stbtt_FindGlyphIndex(&fontLookupHint.font->mFont, codepoint);
					
					printf( " index2 %i\n", index2 );
					
					if (!index2)
						continue;
					
					
					if (isDrawing) {
						sttfont_glyph* G = hbGetGlyphOrTofu(newFontIdx, index2, formatCode);
						
						printf( " G %#04x, %i, %i \n", G, x_offset, y_offset );
						
						if (G) {
							// Harfbuzz doesn't know the glyph size because its not in the font used for shaping
							// We'll use the stb font metrics here
							drawGlyph(G, xx, yy, format, formatCode, 0, overdraw);
							xx += scale*G->advance;
							}
						}
					continue;
					}
				if (isDrawing) {
					sttfont_glyph* G = hbGetGlyphOrTofu(fontIdx, glyphid, formatCode);
					if (G)
						drawGlyph(G, xx + x_offset*hbScaleFactor, yy + y_offset*hbScaleFactor, format, formatCode, 0, overdraw);
					}
				
				xx += x_advance*hbScaleFactor;
				//yy += y_advance;
				}
			//printf("\n");
		#endif //SSF_HARFBUZZ_ENABLED
		return xx;
		}
	
	int processString_worker (const int x, const int y, const char* c, const uint32_t maxLen, const sttfont_format * const format, const bool isDrawing, int * const widthOut, int * const heightOut, const int * const maxWidth, sttfont_lookupHint * mHint, const int * const threshX, const int * const threshY, int * const caretPosition, int initialXOffset) {
		// Scan through function and extract the glyphs
		// returns the x position at the end
		uint32_t seek = 0;
		uint32_t seekLast = 0;
		uint32_t uCharLast = 0;
		
		int xx = x + initialXOffset;
		int overdraw = SSF_INT_MIN;
		int yy = y;
		
		if (mHint) {
			seek = mHint->workingLen;
			seekLast = seek;
			xx = mHint->workingX;
			yy = mHint->workingY;
			uCharLast = mHint->uCharLast;
			}
			
		uint32_t uChar = sttfont_utf8::utf8_read(c+seek, seek, maxLen);
		if (widthOut) { *widthOut = 0; if (mHint) *widthOut = mHint->workingX-x; }
		if (heightOut) { *heightOut = 0; if (mHint) *heightOut = mHint->workingY-y; }
		
		const bool lookupCaret = caretPosition && threshX && threshY;
		if (lookupCaret) {
			*caretPosition = -1;
			}
		
		
		int xxl = xx;
		sttfont_glyph * GLast = NULL;
		findSubfontLookupHint fontLookupHint;
		
		#ifdef SSF_HARFBUZZ_ENABLED
		// Harfbuzz based shaping
		// scan for chunk, shape chunk, process chunk, move to next chunk
		
		uint32_t chunkStart = 0;
		uint16_t currentFont = -1; 
		uint32_t len = maxLen;
		
		bool isLTR = true;
		
		while (seek < maxLen) {
			seekLast = seek; // seek before utf8_read()
			uCharLast = uChar;
			uChar = sttfont_utf8::utf8_read(c+seekLast, seek, maxLen); // seek is now at the character *after* uChar
			if (uChar == 0) {
				len = seek - 1;
				break;
				}
			if (uChar == 0x20) continue;// && uChar <= 0x40) continue; // do not break on whitespace
					
			if (uChar == '\n') {
				// End current chunk before newline
				if (chunkStart < seekLast) {
					if (currentFont == uint16_t(-1))
						currentFont = 0; // assume that we're using the first font. (needed for processing punctiation/whitespace only strings
					printf("chunkEnd 1: working string: [%.*s]\n", seekLast-chunkStart, c + chunkStart);
					xx = processHarfbuzzChunk(c, maxLen, x, xx, yy, format, isDrawing, chunkStart, seekLast, currentFont, fontLookupHint, overdraw, maxWidth, isLTR);
					}

				// Move to next line
				yy += scale*rowSize;
				if (widthOut)
					if (*widthOut < xx) *widthOut = xx;
				xx = x;

				// Skip the newline and start new chunk
				chunkStart = seek; // seek is after uChar
				//currentFont = -1;
				continue;
				}
			
			// note that we're looking up in codepoint mode, and then
			// using the hbFontLookup table to get the fontIdx
			const uint8_t formatCode = format ? format->format : 0;
			uint16_t gFontIdx = hbFindFontForCodepoint(uChar, formatCode);
			
			if (currentFont == uint16_t(-1)) {
				currentFont = gFontIdx;
				}
			else if (currentFont != gFontIdx) {
				// Font change â†’ emit chunk
				
				// Do not chunk based on punctation if the target punct exsits in the current font
				// This is important for RTL scripts such as Hebrew and Arabic
				if ((uChar <= 0x40) || (uChar >= 0x5B && uChar <= 0x60) || (uChar >= 0x7B && uChar <= 0x7E)) {
					continue;
					findSubfontByIndexWHint(currentFont, fontLookupHint);
					if (fontLookupHint.font) {
						int index = stbtt_FindGlyphIndex(&(fontLookupHint.font->mFont), uChar);
						if (index) {
							continue;
							}
						}
					}
				
				if (chunkStart < seekLast) {
					printf("chunkEnd 2. CurrentFont %i, G->fontIdx %i, uCharLast: %#04x, uChar: %#04x, working string: [%.*s]\n", currentFont, gFontIdx, uCharLast, uChar, seekLast-chunkStart, c + chunkStart);
					xx = processHarfbuzzChunk(c, maxLen, x, xx, yy, format, isDrawing, chunkStart, seekLast, currentFont, fontLookupHint, overdraw, maxWidth, isLTR);
					}
				currentFont = gFontIdx;
				chunkStart = seekLast;
				}

			//seek = nextPos;
			}

		// Flush final chunk
		if (chunkStart < len) {
			//if (!c[len]) len--;
			if (currentFont == uint16_t(-1))
				currentFont = 0; // assume that we're using the first font. (needed for processing punctiation/whitespace only strings
			printf("chunkEnd 3: working string: [%.*s]\n", len-chunkStart, c + chunkStart);
			xx = processHarfbuzzChunk(c, maxLen, x, xx, yy, format, isDrawing, chunkStart, len, currentFont, fontLookupHint, overdraw, maxWidth, isLTR);
			}

		
		#else
		// Codepoint based shaping
		while (uChar && seek <= maxLen) {
			//if (mHint)
			//	std::cout << "Processing: (" << seekLast << "," << (seek-seekLast) << ") " << std::string(&c[seekLast], seek-seekLast) << ", codePoint " << uChar << ", suibstring: [" << std::string(&c[seekLast]) << "], fullstring:["<<maxLen<<"] " << c << std::endl;
			xxl = xx;
			if (uChar == '\t') {
				// Next tab position:
				int nTabsSoFar = (xx - x)/tabWidth;
				xx = x + (nTabsSoFar+1)*tabWidth;
				}
			else if (uChar == '\n') {
				if (widthOut)
					if (*widthOut < xx) *widthOut = xx;
				xx = x;
				yy += scale*rowSize;
				overdraw = SSF_INT_MIN;
				}
			else {
				GLast = processCodepoint(GLast, uCharLast, xx, yy, uChar, format, isDrawing, overdraw, fontLookupHint);
				}
			
			if (lookupCaret) {
				//const int dx = xx - x;
				if (xx > *threshX && xxl <= *threshX ) {
					if (*threshX > xxl + (xx - xxl)/2)
						*caretPosition = seek; // right half of char
					else
						*caretPosition = seekLast; // left half of char
						
					if (mHint) {
						if (mHint->writeOut) {
							mHint->workingLen = seek;
							mHint->workingX = xx;
							mHint->workingY = yy;
							mHint->uCharLast = uCharLast;
							}
						}
					return xx;
					}
				}
				
			if (mHint) {
				if (mHint->writeOut) {
					mHint->uCharLast = uCharLast;
					mHint->workingLen = seek;
					mHint->workingX = xx;
					mHint->workingY = yy;
					}
				}
			uCharLast = uChar;
			seekLast = seek;
			uChar = sttfont_utf8::utf8_read(c + seek, seek, maxLen);
			if (maxWidth) {
				if (xx > *maxWidth) break;
				}
			}
		#endif
		if (widthOut) {
			if (*widthOut < xx) *widthOut = xx;
			*widthOut -= x;
			}
		if (heightOut) {
			if (*heightOut < yy) *heightOut = yy;
			*heightOut += scale*rowSize;
			*heightOut -= y;
			}
		return xx;
		}
		
public:
	int processFormatted(const sttfont_formatted_text & text, int x, int y, const bool isDrawing, int * const widthOut = NULL, int * const heightOut = NULL, const int * const maxHeight = NULL, sttfont_lookupHint * mHint = NULL, const int * const threshX = NULL, const int * const threshY = NULL, int * const caretPosition = NULL, int initialXOffset = 0) {
		onStartDrawing();
		int ret = processFormatted_worker(text, x, y, isDrawing, widthOut, heightOut, maxHeight, mHint, threshX, threshY, caretPosition, initialXOffset);
		onCompletedDrawing();
		return ret;
		}
		
	int processFormatted_worker(const sttfont_formatted_text & text, int x, int y, const bool isDrawing, int * const widthOut = NULL, int * const heightOut = NULL, const int * const maxHeight = NULL, sttfont_lookupHint * mHint = NULL, const int * const threshX = NULL, const int * const threshY = NULL, int * const caretPosition = NULL, int initialXOffset = 0) {
		int xOffset = initialXOffset;
		int yOffset = 0;
		
		if (widthOut) *widthOut = 0;
		if (heightOut) *heightOut = 0;
		
		size_t runningLength = 0;
		
		unsigned int start = 0;
		if (mHint) start = mHint->index;
		
		for (unsigned int i = start; i < text.mItems.size(); ++i) {
			const sttfont_formatted_text_item & ssfti = text.mItems[i];
			
			bool isDrawingWorking = isDrawing;
			if (ssfti.callback && isDrawingWorking)
				isDrawingWorking = (ssfti.format.format & sttfont_format::FORMAT_RENDER_EVEN_IF_CALLBACK_EXISTS);
			
			int widthWorking, heightWorking;
			
			int xOffsetBefore = xOffset;
			int carretPosition2 = -1;
			
			if (mHint) {
				if (mHint->writeOut) {
					mHint->index = i;
					}
				if (i != start) {
					mHint->workingLen = 0;
					mHint->workingX = 0;
					mHint->workingY = 0;
					}
				}
				
			xOffset = processString_worker(x,y + yOffset, ssfti.text.data(), ssfti.text.size(), &ssfti.format, isDrawingWorking, &widthWorking, &heightWorking, maxHeight, mHint, threshX, threshY, caretPosition ? &carretPosition2 : NULL, xOffset); // color!!!
			
			if (caretPosition) {
				if (carretPosition2 >= 0)
					*caretPosition = runningLength + carretPosition2;
				runningLength += ssfti.text.size(); // running length is only calculated here as its only used here
				}
			
			xOffset -= x;
			yOffset += heightWorking - scale*rowSize;
			if (widthOut) *widthOut = *widthOut > widthWorking ? *widthOut : widthWorking;
			
			heightWorking = yOffset + scale*rowSize;
			if (heightOut) *heightOut = *heightOut > heightWorking ? *heightOut : heightWorking;
			
			if (ssfti.callback)
				ssfti.callback->callbackOnDraw(text, i, x, y, xOffsetBefore, xOffset, widthWorking, heightWorking);
			}
		
		int ret = xOffset + x; 
		return ret;
		}
	
	
	/// Returns the position in the string where a click happend
	/// MouseX and MouseY are relative to whatever draw position of this string you are using
	/// Currently only suppors single row strings
	int getCaretPos(const SSF_STRING & str, const int relMouseX, const int relMouseY, sttfont_lookupHint * mHint = NULL) {
		int caretPosition = -1;
		processString(0,0, str.data(), str.length(), NULL, false, NULL, NULL, NULL, mHint, &relMouseX, &relMouseY, &caretPosition);
		return caretPosition;
		}
	int getCaretPos(const sttfont_formatted_text & str, const int relMouseX, const int relMouseY, sttfont_lookupHint * mHint = NULL) {
		int caretPosition = -1;
		processFormatted(str, 0,0, false, NULL, NULL, NULL, mHint, &relMouseX, &relMouseY, &caretPosition);
		return caretPosition;
		}
	
	///////////////////////////////////////////////////////////////////
	// Codepoint based glyph processing
	
	inline static bool isTofu (sttfont_glyph * G) {
		if (!G) return true;
		if (G->advance == 0 && G->width == 0) return true; //unprintable characters have no width
		return false;
		}
	
	/// Returns either a glyph with a valid texture, or a tofu glyph with a valid texture or NULL
	sttfont_glyph * getCodepointGlyphOrTofu (const uint32_t codepoint, const uint8_t format) {
		const uint8_t format_wo_underline_or_strike = format & ~(sttfont_format::FORMAT_STRIKETHROUGH | sttfont_format::FORMAT_UNDERLINE);
		sttfont_glyph * G = getGenGlyph(codepoint, format_wo_underline_or_strike, 0, 0);
		
		if (!isTofu(G)) return G;
		
		printf("failed to find %#04x\n", codepoint);
		
		G = getGenGlyph((uint32_t) 0xFFFD, format_wo_underline_or_strike, 0, 0); // https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
		if (!isTofu(G)) return G;
			
		G = getGenGlyph((uint32_t) '?', format_wo_underline_or_strike, 0, 0);
		if (!isTofu(G)) return G;
		
		if (format_wo_underline_or_strike)
			return getCodepointGlyphOrTofu(codepoint, 0);
		
		return NULL;
		}
	
	// NOTE: 2022 - processCodepoint is no longer virtual - instead use drawCodepoint as your injection point for frontends
	sttfont_glyph* getCodepointGlyph(const uint32_t codepoint, const sttfont_format * const format) {
		uint8_t formatCode = 0;
		if (format)
			formatCode = format->format;
		return getCodepointGlyphOrTofu(codepoint, formatCode);
		}
	
	sttfont_glyph* processCodepoint (sttfont_glyph* GLast, const uint32_t codepointLast, int & x, int & y, const uint32_t codepoint, const sttfont_format * const format, bool isDrawing, int & overdraw, findSubfontLookupHint & mHint) {
		// Draws the character, advances x & y to the next position
		uint8_t formatCode = 0;
		if (format)
			formatCode = format->format;
			
		sttfont_glyph * G = getCodepointGlyphOrTofu(codepoint, formatCode);
		if (!G) {
			x += faceSize/2;
			return NULL;
			}
		
		int kerningAdv = 0;
		if (GLast)
			kerningAdv = scale*getKerningAdvance(GLast, G, codepointLast, codepoint, mHint);
		x += kerningAdv;
		
		if (isDrawing) {
			drawGlyph(G, x, y, format, formatCode, kerningAdv, overdraw); //<--- implement your custom version of this
			}
		x += scale*G->advance;
		
		return G;
		}
		
	virtual void drawGlyph (const sttfont_glyph * const GS, const int x, const int y, const sttfont_format * const format, const uint8_t formatCode, const int kerningAdv, int & overdraw) {
		// Draws the character
		// @overdraw: This is used for fixing pixel bleed on some backends (such as SDL). If your backend doesn't bleed then you can ignore it
		// Make your own implmentation for your own frontend here
		}
		
	///////////////////////////////////////////////////////////////////
	// HarfBuzz based glyph processing
	
	// Returns a glyph or a tofu glyph for rendering. hb version of getCodepointGlyphOrTofu
	sttfont_glyph * hbGetGlyphOrTofu (const uint16_t fontIdx, const uint16_t intIdx, const uint8_t format) {
		const uint8_t format_wo_underline_or_strike = format & ~(sttfont_format::FORMAT_STRIKETHROUGH | sttfont_format::FORMAT_UNDERLINE);
		sttfont_glyph * G = getGenGlyph(0, format_wo_underline_or_strike, fontIdx, intIdx);
		
		if (!isTofu(G)) return G;
		
		G = getGenGlyph(0, format_wo_underline_or_strike, 0, hbUnicodeReplacementCodeGlyphIndex);
		if (!isTofu(G)) return G;
		
		G = getGenGlyph(0, format_wo_underline_or_strike, 0, hbQuestionMarkGlyphIndex);
		if (!isTofu(G)) return G;
		
		if (format_wo_underline_or_strike)
			return hbGetGlyphOrTofu(fontIdx, intIdx, 0);
		
		return NULL;
		}
		
	/// Creates a SDL_Texture of a suitable size and renders an entire string to it
	//SDL_Texture * renderTextToTexture (const char * c, const uint32_t maxLen = -1, int * widthOut = NULL, int * heightOut = NULL) {
	//	return renderTextToTexture_worker(NULL, c, maxLen, widthOut, heightOut);
	//	}
	//SDL_Texture * renderTextToTexture (const sttfont_formatted_text & formatted, int * widthOut = NULL, int * heightOut = NULL) {
	//	return renderTextToTexture_worker(&formatted, NULL, -1, widthOut, heightOut);
	//	}
	//SDL_Texture * renderTextToTexture (const SSF_STRING & str, int * widthOut = NULL, int * heightOut = NULL) {
	//	return renderTextToTexture(str.data(), str.length(), widthOut, heightOut);
	//	}
	//SDL_Texture * renderTextToTexture_worker (const sttfont_formatted_text * formatted, const char * c, const uint32_t maxLen = -1, int * widthOut = NULL, int * heightOut = NULL) {
	//	// Make your own implmentation for your own frontend here
	//	}

	/// Same as renderTextToTexture, but stores the result in an object that has a convienent 
	virtual void renderTextToObject (sttfont_prerendered_text * textOut, const char * c, const uint32_t maxLen = -1) {
		// Make your own implmentation for your own frontend here
		//textOut->mSdlTexture = renderTextToTexture(c, maxLen, &(textOut->width), &(textOut->height));
		}
	virtual void renderTextToObject (sttfont_prerendered_text * textOut, const SSF_STRING & str) {
		// Make your own implmentation for your own frontend here
		//textOut->mSdlTexture = renderTextToTexture(str, &(textOut->width), &(textOut->height));
		}
	virtual void renderTextToObject (sttfont_prerendered_text * textOut, const sttfont_formatted_text & str) {
		// Make your own implmentation for your own frontend here
		//textOut->mSdlTexture = renderTextToTexture(str, &(textOut->width), &(textOut->height));
		}
	
	/// Breaks a string into a vector of substrings such that each string is not longer xs
	/// Tries to break on whitespace, if it cannot then it will split based on characters
	/// UTF-8 safe
	void breakString (const sttfont_formatted_text & stringIn, SSF_VECTOR<sttfont_formatted_text> & arrOut, const int xs,
		const bool tokeniseNewLines = true, SSF_VECTOR<sttfont_uintQuad> * breakPoints = NULL) {
		// Note: This some of the ugliest code I have ever written. Look upon it and weap
		if (tokeniseNewLines) {
			SSF_VECTOR<sttfont_formatted_text> tokenised;
			stringIn.tokenise(tokenised, '\n', false, 0);
			
			for (sttfont_formatted_text & sft : tokenised) {
				breakString(sft, arrOut, xs, false, breakPoints);
				}
			return;
			}
		
		//std::cout << "Breaking: " << stringIn.getString() << ", xs: " << xs << std::endl;
		
		// Trivial cases
		if (getTextWidth(stringIn) < xs) {
			if (breakPoints) breakPoints->push_back(sttfont_uintQuad(arrOut.size(), 0, stringIn.size()));
			arrOut.push_back(stringIn.copy());
			return;
			}
			
		SSF_VECTOR<sttfont_formatted_text> tokenised;
		stringIn.tokenise(tokenised, ' ', false, 0, true);
		
		
		size_t lastInsert = 0;
		uint32_t workingLen = 0;	// Working length in pixels
		uint32_t iWorkingLen = 0;	// Working length in bytes
		uint32_t iWorkingLenLastBreak = 0;	// The length at the last break. Effectivley the start point of a split
		uint32_t spaceLen = 0;
		
		spaceLen = getTextWidth(sttfont_formatted_text(" "));
		
		#if 0
			{
			std::cout << "String [" << stringIn.getString() << "], Tokens: (" << tokenised.size() << ") ";
			for (size_t ti = 0; ti < tokenised.size(); ++ti) {
				if (ti) std::cout <<", ";
				std::cout << "[" << tokenised[ti].getString() << "]";
				}
			std::cout << std::endl;
			}
		#endif
		
		int maxLenLookup = xs + spaceLen; // If a string is longer than this, stop calcualting its length (early out)
		
		for (size_t ti = 0; ti < tokenised.size(); ++ti) {
			bool breakLongWord = false;
			int tokLen = 0;
			//uint64_t TSTART = 0;
			//topOfLoop:
			//TSTART = SDL_GetPerformanceCounter();
			const sttfont_formatted_text & thisTokenS = tokenised[ti];
			
			tokLen = getTextWidth(thisTokenS, NULL, &maxLenLookup);
			
			// Check last character is space. If it is, ignore the length of it
			if (thisTokenS.mItems.size()) {
				const SSF_STRING & str = thisTokenS.mItems[thisTokenS.mItems.size()-1].text;
				if (str.size()) {
					if (str[str.size()-1] == ' ')
						tokLen -= spaceLen;
					}
				}
			
			if (tokLen > xs) {
				// Break this token
				uint32_t subWorkingLen = 0;
				sttfont_lookupHint mHint;
					mHint.writeOut = true;
				sttfont_lookupHint mHint2;
					mHint.writeOut = true;
					
				sttfont_formatted_text subToken;
				int tokLen2Last = 0;
					
				for (size_t si = 0; si < thisTokenS.mItems.size(); ++si) {
					const SSF_STRING & s = thisTokenS.mItems[si].text;
					const uint32_t len = s.length();
					
					uint32_t seek = 0;
					uint32_t seekBefore = 0;
					
					while (seek < len) {
						seekBefore = seek;
						sttfont_utf8::utf8_read(&s[seek], seek, len); // Look ahead and discard value
					
						sttfont_formatted_text subToken2 =  thisTokenS.extract(seekBefore+subWorkingLen, seek-seekBefore, &mHint2);
						subToken.append(std::move(subToken2));
						
						int tokLen2 = getTextWidth(subToken, &mHint);
						
						if (tokLen2 > xs) {
							//split!
							uint32_t splitPos = subWorkingLen + seekBefore;
							if (splitPos == 0) splitPos = 1;
							if (splitPos < len) {
								sttfont_formatted_text before = thisTokenS.extract(0, splitPos);
								sttfont_formatted_text after  = thisTokenS.extract(splitPos, -1);
								//std::cout << "here!!! ["<< thisTokenS.getString() <<"] (" << splitPos << "/" << thisTokenS.size() << ") before: [" << before.getString() << "], after: [" << before.getString() << "]" << std::endl;

								tokenised.insert(tokenised.begin() + ti + 1, std::move(after));
								tokenised[ti].swap(before);
								
								
								//std::cout << "here!!! [" << tokenised[ti].getString() << std::endl;
				//uint64_t TSPLIT = SDL_GetPerformanceCounter();
				//const double deltaTime = (double)((TSPLIT - TSTART)*1000 / (double)SDL_GetPerformanceFrequency() );
				//std::cout  << std::endl << "TokLen: [" << tokenised[ti].size() << "/" << tokenised[ti+1].size() << "],  Split time: " << deltaTime <<"ms" << " before: [" << tokenised[ti].getStringTruncated(64) << "] after: [" << tokenised[ti+1].getStringTruncated(64) << "] "<< std::endl << std::endl;
								//ti--;
								}
							
							tokLen = tokLen2Last;
							breakLongWord = true;
							goto breaken;
							}
						tokLen2Last = tokLen2;
						}
					subWorkingLen += len;
					}
				}
				
			// I told you this is ugly code. Look, it even has a Goto!
			breaken:
			
			//				std::cout << "breaken: [" << tokenised[ti].getString() << "] " << ti << "/" << tokenised.size() << " " << (workingLen + tokLen) << "/" << xs << std::endl;
			
			/////////////////////////////////////////////////////////////////////
			// Token for 
			//const sttfont_formatted_text & thisToken = tokenised[ti];
			
			bool isOverLength = (workingLen + tokLen > unsigned(xs));
			bool isLastPiece = (ti == tokenised.size()-1);
			
				
			if (isOverLength || isLastPiece || breakLongWord) {
				sttfont_formatted_text working;
				//bool first = true;
				unsigned int tokStride = 0;
				size_t limit = ti;
				if (!isOverLength)
					limit = ti+1;
					
				//bool isLastPiece2 = (limit == tokenised.size());
				for (size_t tj = lastInsert; tj < limit; ++tj) {
					//std::cout << "tok: [" << tokenised[tj].getString() << "] " << (tj+1 < limit ) << " " << tokStride << std::endl;
					working.append(std::move(tokenised[tj]));
					}
				//const bool trailingSpace = (!isLastPiece2) && (!breakLongWord);
				//if (trailingSpace)
				//	working << " ";
					
				working.consolidateSegments();
				
				if (breakPoints) {
					//if (isLastPiece)
					//tokStride = 0;
					iWorkingLen = working.size();
					
					//std::cout << "Insert B " << tokLen << "/" << Vgui_ContextI::aContext->getTextWidth(working) << "/" << xs << "\t[" << working.getString() << "], this piece: " << thisToken.getString() << ", arrSize: " << arrOut.size() << ", workingLen: " << iWorkingLen  << " workingLenLastBreak : " << iWorkingLenLastBreak << ", tokStride: " << tokStride << ", breakLongWord: " << breakLongWord << " isLastPiece2: " << isLastPiece2 << " trailingSpace: " << (trailingSpace) << std::endl << std::endl;
					
					breakPoints->push_back(sttfont_uintQuad(arrOut.size(), iWorkingLenLastBreak, iWorkingLen, tokStride));
					iWorkingLenLastBreak += iWorkingLen + tokStride;
					}
				arrOut.push_back(std::move(working));
				
				lastInsert = limit;
				if (isOverLength)
					ti--;
					
				workingLen = 0;
				//iWorkingLen = 0;
				}
			else {
				workingLen += tokLen + spaceLen;
				}
			
			//exit(1);
			}
		}
	
	void breakString (const SSF_STRING & stringIn, SSF_VECTOR<SSF_STRING> & arrOut, const int xs,
		const bool tokeniseNewLines = true, SSF_VECTOR<sttfont_uintQuad> * breakPoints = NULL) {
		sttfont_formatted_text sft;
		sft << stringIn;
		
		SSF_VECTOR<sttfont_formatted_text> arrTemp;
		breakString(sft, arrTemp, xs, tokeniseNewLines, breakPoints);
		arrOut.resize(arrTemp.size());
		for (uint32_t i = 0; i < arrTemp.size(); ++i) {
			if (arrTemp[i].isEmpty()) continue;
			arrOut[i].swap(arrTemp[i].mItems[0].text);
			}
		}
		 
	}
