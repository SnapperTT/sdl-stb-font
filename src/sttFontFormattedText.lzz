#hdr
namespace stt {
	class allocatorI;
	}
// purpose: an allocator that puts string objects onto a stack memory buffer
// when the buffer falls out of scope then the buffer is released
#ifndef SSF_STT_STL_ALLOCATOR_ENABLED
	#define SSF_STT_STL_ALLOCATOR_ENABLED 0
#endif

namespace sttfont {
	template<typename T>
	inline void allocator_aware_move_or_copy(T& dst, T& src) {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			// Same allocator? Move. Different allocator? copy
			if (dst.getCustomAllocator() == src.getCustomAllocator())
				dst = std::move(src);
			else
				dst = src;
			return;
		#else
			dst = std::move(src);
		#endif
		}
	}
#end

/// Lookup Hint
struct sttfont_lookupHint {
	unsigned int index;
	unsigned int workingLen;
	int workingX, workingY;		// Working values to do with X and Y stuff. Meaning changes based on the context
	uint32_t uCharLast;
	bool writeOut;				// If true, this will be updated after calling getIndexAt
	sttfont_lookupHint() : index(0), workingLen(0), workingX(0), workingY(0), uCharLast(0), writeOut(false) {}
	};

/// Formatted text
struct sttfont_format_callback {
	virtual void callbackOnDraw(const sttfont_formatted_text & text, int index, int x, int y, int xOffsetInitial, int xOffsetAfter, int segmentWidth, int segmentHeight) {}
	};
	
// Include file for sttfont_font

struct sttfont_format_reset {};
struct sttfont_format {
	uint8_t r,g,b,a;
	uint8_t format;
	uint8_t flags;
	uint16_t padding;	// align to 64 bits
	static const uint8_t FORMAT_NONE 		  = 0 << 0;
	static const uint8_t FORMAT_BOLD 		  = 1 << 0;
	static const uint8_t FORMAT_ITALIC 		  = 1 << 1;
	static const uint8_t FORMAT_UNDERLINE 	  = 1 << 2;
	static const uint8_t FORMAT_STRIKETHROUGH = 1 << 3;
	static const uint8_t FORMAT_RENDER_EVEN_IF_CALLBACK_EXISTS = 1 << 7;
	
	static const uint8_t FORMAT_FLAGS_COLOUR_SET 	   = 1 << 0;	// Colour has been manually set and can therefore be overridden by sttfont_formatted_text::overrideColour
	
	inline sttfont_format() : r(255), g(255), b(255), a(255), format(0), flags(0), padding(0) {}
	inline sttfont_format(const uint8_t _format)
					: r(255), g(255), b(255), a(255), format(_format), flags(0), padding(0) {}
	inline sttfont_format(const uint8_t _format, const uint8_t _r, const uint8_t _g, const uint8_t _b, const uint8_t _a = 255)
					: r(_r), g(_g), b(_b), a(_a), format(_format), flags(FORMAT_FLAGS_COLOUR_SET), padding(0) {}
	
	inline sttfont_format clone() const { sttfont_format r; r = *this; return r; }
	
	inline bool operator == (const sttfont_format & other) const { // use default operator
		return (r == other.r) && (g == other.g) && (b == other.b) && (a == other.a) && (format == other.format) && (flags == other.flags);
		}
	
	inline void setBold(const bool on) { if (on) format |= FORMAT_BOLD; else format &= ~FORMAT_BOLD; }
	inline void setItalic(const bool on) { if (on) format |= FORMAT_ITALIC; else format &= ~FORMAT_ITALIC; }
	inline void setUnderline(const bool on) { if (on) format |= FORMAT_UNDERLINE; else format &= ~FORMAT_UNDERLINE; }
	inline void setStrikethrough(const bool on) { if (on) format |= FORMAT_STRIKETHROUGH; else format &= ~FORMAT_STRIKETHROUGH; }
	inline bool isBold() const { return format & FORMAT_BOLD; }
	inline bool isItaic() const { return format & FORMAT_ITALIC; }
	inline bool isUnderline() const { return format & FORMAT_UNDERLINE; }
	inline bool isStrikethrough() const { return format & FORMAT_STRIKETHROUGH; }
	inline bool hasFormats() const { return format; }
	void resetColour() { r = 255, b = 255, g = 255, a = 255; flags &= ~FORMAT_FLAGS_COLOUR_SET; }
	
	void combine(const sttfont_format & other) {
		// merges flags and blends colours multiplicatively
		format |= other.format;
		flags |= other.flags;
		r = 255*((r/255.0)*(other.r/255.0));
		g = 255*((g/255.0)*(other.g/255.0));
		b = 255*((b/255.0)*(other.b/255.0));
		a = 255*((a/255.0)*(other.a/255.0));
		}
		
	void combineWithColour(const sttfont_format & other) {
		// merges formats and overrides colour
		format |= other.format;
		flags |= other.flags;
		r = other.r;
		g = other.g;
		b = other.b;
		a = other.a;
		}
		
	static sttfont_format color (const uint8_t _r, const uint8_t _g, const uint8_t _b, const uint8_t _a = 255) { sttfont_format ret(FORMAT_NONE,_r,_g,_b,_a); ret.flags |= FORMAT_FLAGS_COLOUR_SET; return ret; }
	static sttfont_format colour(const uint8_t _r, const uint8_t _g, const uint8_t _b, const uint8_t _a = 255) { sttfont_format ret(FORMAT_NONE,_r,_g,_b,_a); ret.flags |= FORMAT_FLAGS_COLOUR_SET; return ret; }
	
	static sttfont_format color_luasafe (const uint8_t _r, const uint8_t _g, const uint8_t _b) { return color(_r,_g,_b,255); }
	static sttfont_format colour_luasafe(const uint8_t _r, const uint8_t _g, const uint8_t _b) { return colour(_r,_g,_b,255); }
	
	
	// Constants and "constants"
	static const sttfont_format bold = sttfont_format(FORMAT_BOLD);
	static const sttfont_format italic = sttfont_format(FORMAT_ITALIC);
	static const sttfont_format underline = sttfont_format(FORMAT_UNDERLINE);
	static const sttfont_format strikethrough = sttfont_format(FORMAT_STRIKETHROUGH);
	// If you don't like the colours, extend this class and define your own
	static const sttfont_format red 	= sttfont_format(FORMAT_NONE,255,  0,  0,255);
	static const sttfont_format green	= sttfont_format(FORMAT_NONE,  0,255,  0,255);
	static const sttfont_format blue 	= sttfont_format(FORMAT_NONE,  0,  0,255,255);
	static const sttfont_format yellow 	= sttfont_format(FORMAT_NONE,255,255,  0,255);
	static const sttfont_format black 	= sttfont_format(FORMAT_NONE,  0,  0,  0,255);
	static const sttfont_format white	= sttfont_format(FORMAT_NONE,255,255,255,255);
	static const sttfont_format magenta	= sttfont_format(FORMAT_NONE,255,  0,255,255);
	static const sttfont_format cyan	= sttfont_format(FORMAT_NONE,  0,255,255,255);
	static const sttfont_format grey	= sttfont_format(FORMAT_NONE,128,128,128,255);
	
	static const sttfont_format light_red 		= sttfont_format(FORMAT_NONE,255,  128,  128,255);
	static const sttfont_format light_green		= sttfont_format(FORMAT_NONE,  128,255,  128,255);
	static const sttfont_format light_blue 		= sttfont_format(FORMAT_NONE,  128,  128,255,255);
	static const sttfont_format light_yellow	= sttfont_format(FORMAT_NONE,255,255,  128,255);
	static const sttfont_format light_black 	= sttfont_format(FORMAT_NONE,  128,  128,  128,255);
	static const sttfont_format light_white		= sttfont_format(FORMAT_NONE,255,255,255,255);
	static const sttfont_format light_magenta	= sttfont_format(FORMAT_NONE,255,  128,255,255);
	static const sttfont_format light_cyan		= sttfont_format(FORMAT_NONE,  128,255,255,255);
	static const sttfont_format light_grey		= sttfont_format(FORMAT_NONE,192,192,192,255);
	
	static const sttfont_format dark_red 		= sttfont_format(FORMAT_NONE,128,  0,  0,255);
	static const sttfont_format dark_green		= sttfont_format(FORMAT_NONE,  0,128,  0,255);
	static const sttfont_format dark_blue 		= sttfont_format(FORMAT_NONE,  0,  0,128,255);
	static const sttfont_format dark_yellow		= sttfont_format(FORMAT_NONE,128,128,  0,255);
	static const sttfont_format dark_black 		= sttfont_format(FORMAT_NONE,  0,  0,  0,255);
	static const sttfont_format dark_white		= sttfont_format(FORMAT_NONE,128,128,128,255);
	static const sttfont_format dark_magenta	= sttfont_format(FORMAT_NONE,128,  0,128,255);
	static const sttfont_format dark_cyan		= sttfont_format(FORMAT_NONE,  0,128,128,255);
	static const sttfont_format dark_grey		= sttfont_format(FORMAT_NONE,64,64,64,255);
	
	const static int COLOUR_MODE_NORMAL = 0;
	const static int COLOUR_MODE_DARKEN = 1;
	const static int COLOUR_MODE_LIGHTEN = 2;
	
	static const sttfont_format& selectColour(const int colourMode, const sttfont_format& colourIf0, const sttfont_format& colourIf1, const sttfont_format& colourIf2) {
		if (colourMode == 1) return colourIf1;
		if (colourMode == 2) return colourIf2;
		return colourIf0;
		}
	
	static const sttfont_format_reset reset;
	
	void swap(sttfont_format & other) {
		sttfont_format tmp = *this;
		*this = other;
		other = tmp;
		}
		
	SSF_STRING getTtyFormatCodeBegin() const {
		if (!(hasFormats() || r != 255 || g != 255 || b != 255))
			return "";
		SSF_STRING rs = "\033[";
		ttyFmtWorker(rs);
		return rs + "m";
		}
		
	SSF_STRING getTtyFormatCodeEnd() const {
		if (!(hasFormats() || r != 255 || g != 255 || b != 255))
			return "";
		return "\033[0m";
		}
		
	void ttyFmtWorker(SSF_STRING & rs) const {
		bool first = false;
		if (r != 255 || g != 255 || b != 255) {
			if (first) rs += ";";
			char arr[64];
			snprintf(arr, 63, "38;2;%i;%i;%i", r, g, b);
			rs += arr;
			first = true;
			}
		if (isBold()) {
			if (first) rs += ";";
			rs += "1";
			first = true;
			}
		if (isItaic()) {
			if (first) rs += ";";
			rs += "3";
			first = true;
			}
		if (isUnderline()) {
			if (first) rs += ";";
			rs += "4";
			first = true;
			}
		if (isStrikethrough()) {
			if (first) rs += ";";
			rs += "9";
			first = true;
			}
		}
		
	SSF_STRING debugDump() const {
		SSF_STRING rs;
		ttyFmtWorker(rs);
		return "[fmt:" + rs + "]";
		}
		
	static void sttr_register() {
		#ifdef STTR_ENABLED
		#define STTR_REGF_ALIAS(C,X,A,F) regField<C,decltype(&C::X),F>(&C::X,#A).setUserFlags(F)
		// Reflection stuff - see snappertt/sttr on github for more info. You don't need STTR to use this library
		sttr::RegNamespace & R = *sttr::getGlobalNamespace();
		R.beginClass<sttfont_format>("sttfont_format")
			.STTR_REGF(sttfont_format,r,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_format,g,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_format,b,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_format,a,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_format,format,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_format,flags,STTR_JSON_ENABLED)
			
			.STTR_REG(sttfont_format,clone)
			.STTR_REG(sttfont_format,combine)
			.STTR_REG(sttfont_format,combineWithColour)
			
			.STTR_REG(sttfont_format,setBold)
			.STTR_REG(sttfont_format,setItalic)
			.STTR_REG(sttfont_format,setUnderline)
			.STTR_REG(sttfont_format,setStrikethrough)
			.STTR_REG(sttfont_format,isBold)
			.STTR_REG(sttfont_format,isItaic)
			.STTR_REG(sttfont_format,isUnderline)
			.STTR_REG(sttfont_format,isStrikethrough)
			.STTR_REG(sttfont_format,hasFormats)
			.STTR_REG(sttfont_format,resetColour)
			
			.STTR_REGF_ALIAS(sttfont_format,colour_luasafe,colour,0)
			.STTR_REGF_ALIAS(sttfont_format,color_luasafe,color,0)
			.STTR_REG(sttfont_format,bold)
			.STTR_REG(sttfont_format,italic)
			.STTR_REG(sttfont_format,underline)
			.STTR_REG(sttfont_format,strikethrough)
			
			.STTR_REG(sttfont_format,red)
			.STTR_REG(sttfont_format,green)
			.STTR_REG(sttfont_format,blue)
			.STTR_REG(sttfont_format,yellow)
			.STTR_REG(sttfont_format,black)
			.STTR_REG(sttfont_format,white)
			.STTR_REG(sttfont_format,magenta)
			.STTR_REG(sttfont_format,cyan)
			.STTR_REG(sttfont_format,grey)
			
			.STTR_REG(sttfont_format,light_red)
			.STTR_REG(sttfont_format,light_green)
			.STTR_REG(sttfont_format,light_blue)
			.STTR_REG(sttfont_format,light_yellow)
			.STTR_REG(sttfont_format,light_black)
			.STTR_REG(sttfont_format,light_white)
			.STTR_REG(sttfont_format,light_magenta)
			.STTR_REG(sttfont_format,light_cyan)
			.STTR_REG(sttfont_format,light_grey)
			
			.STTR_REG(sttfont_format,dark_red)
			.STTR_REG(sttfont_format,dark_green)
			.STTR_REG(sttfont_format,dark_blue)
			.STTR_REG(sttfont_format,dark_yellow)
			.STTR_REG(sttfont_format,dark_black)
			.STTR_REG(sttfont_format,dark_white)
			.STTR_REG(sttfont_format,dark_magenta)
			.STTR_REG(sttfont_format,dark_cyan)
			.STTR_REG(sttfont_format,dark_grey)
			
			.STTR_REG(sttfont_format,COLOUR_MODE_NORMAL)
			.STTR_REG(sttfont_format,COLOUR_MODE_DARKEN)
			.STTR_REG(sttfont_format,COLOUR_MODE_LIGHTEN)
			.STTR_REG(sttfont_format,selectColour)
			
			.STTR_REG(sttfont_format,reset)
			
			.STTR_REG(sttfont_format,getTtyFormatCodeBegin)
			.STTR_REG(sttfont_format,getTtyFormatCodeEnd)
			.STTR_REG(sttfont_format,debugDump)
		.endClass();
		#undef STTR_REGF_ALIAS
		#endif
		}
	STTFONT_STTR_CLASS_SIG_NON_POLY(sttfont_format)
	
	};
	
struct sttfont_formatted_text_item {
	SSF_STRING text;		// want: sizeof 32 for sso? 64 - (8+8) = 48?
	sttfont_format format;	// sizeof = 8
	sttfont_format_callback * callback; // sizeof = 8. Replace with flag/union?
	
	sttfont_formatted_text_item () : callback(0) {}
	sttfont_formatted_text_item (const SSF_STRING & _text, const sttfont_format & _format)	: text(_text), format(_format), callback(0) {}
	sttfont_formatted_text_item (SSF_STRING_MS _text, const sttfont_format & _format) 		: text(std::move(_text)), format(_format), callback(0) {}
	sttfont_formatted_text_item& setCallback(sttfont_format_callback* _cb) { callback = _cb; return *this; }
	
	void setAllocator(stt::allocatorI* alloc) {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			text.setAllocator(alloc);
		#endif
		}
		
	stt::allocatorI* getCustomAllocator() const {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			return text.getCustomAllocator();
		#endif
		return NULL;
		}
	//inline stt::allocatorI* __sttstl_getCustomAllocator() const { return getCustomAllocator(); } // this signutre is required for allocator aware stt::vector::push_back(t&& v)
	
	static void sttr_register() {
		#ifdef STTR_ENABLED
		sttr::RegNamespace & R = *sttr::getGlobalNamespace();
		R.beginClass<sttfont_formatted_text_item>("sttfont_formatted_text_item")
			.STTR_REGF(sttfont_formatted_text_item,text,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_formatted_text_item,format,STTR_JSON_ENABLED)
		.endClass();
		#endif
		}
	STTFONT_STTR_CLASS_SIG_NON_POLY(sttfont_formatted_text_item)
	};

struct sttfont_formatted_uipair {
	unsigned int a,b;
	static void sttr_register() {
		#ifdef STTR_ENABLED
		sttr::RegNamespace & R = *sttr::getGlobalNamespace();
		R.beginClass<sttfont_formatted_uipair>("sttfont_formatted_uipair")
			.STTR_REGF(sttfont_formatted_uipair,a,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_formatted_uipair,b,STTR_JSON_ENABLED)
		.endClass();
		#endif
		}
	STTFONT_STTR_CLASS_SIG_NON_POLY(sttfont_formatted_text_item)
	};

struct sttfont_formatted_text {
	SSF_VECTOR<sttfont_formatted_text_item> mItems; // sizeof = 24. want: sizeof(sttfont_formatted_text_item) +2 for sso? 62 for alignment + 2 overhead per element?
	sttfont_format activeFormat;
	
	// Normal constructors
	sttfont_formatted_text(){}
	sttfont_formatted_text(stt::allocatorI * alloc) {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
		if (alloc)
			mItems.setAllocator(alloc);
		#endif
		}
	sttfont_formatted_text(const sttfont_formatted_text & obj) { allocatorAwareAssign(obj); };
	sttfont_formatted_text(const SSF_STRING & text) { *this << text; }
	sttfont_formatted_text(SSF_STRING_MS text) 		{ *this << text; }
	sttfont_formatted_text(const char * text) 		{ *this << text; }
	sttfont_formatted_text(const char * text, const uint32_t maxLen) { appendCBuff(text, maxLen); }
	
	sttfont_formatted_text(sttfont_formatted_text_item_MS text)			{ allocatorAwareAppendMv(std::move(text)); }
	sttfont_formatted_text(const sttfont_formatted_text_item & text)	{ allocatorAwareAppend(text); }
	sttfont_formatted_text(sttfont_formatted_text_MS obj){ allocatorAwareAssignMv(std::move(obj)); }
		
	sttfont_formatted_text& operator = (sttfont_formatted_text_MS obj){ allocatorAwareAssignMv(std::move(obj)); return *this; }
	sttfont_formatted_text& operator = (const sttfont_formatted_text & obj){ allocatorAwareAssign(obj); return *this; }
	void resetFormat() { activeFormat = sttfont_format(); }
	sttfont_formatted_text& operator << (const SSF_STRING_VIEW& text) 		{ append_plaintext_BUF(text.data(), text.length(), &activeFormat); resetFormat(); return *this;  }
	sttfont_formatted_text& operator << (const SSF_STRING & text) 	{ append_plaintext_str(text, &activeFormat); resetFormat(); return *this; }
	sttfont_formatted_text& operator << (SSF_STRING_MS text) 		{ append_plaintext_MS(std::move(text), &activeFormat); resetFormat(); return *this;  }
	sttfont_formatted_text& operator << (const char * text) 		{ appendCBuff(text, -1); resetFormat(); return *this;  }
	sttfont_formatted_text& operator += (const SSF_STRING_VIEW& text) 		{ append_plaintext_BUF(text.data(), text.length(),  &activeFormat); resetFormat(); return *this;  }
	sttfont_formatted_text& operator += (const SSF_STRING & text) 	{ append_plaintext_str(text, &activeFormat); resetFormat(); return *this; }
	sttfont_formatted_text& operator += (SSF_STRING_MS text) 		{ append_plaintext_MS(std::move(text), &activeFormat); resetFormat(); return *this;  }
	sttfont_formatted_text& operator += (const char * text) 			{ appendCBuff(text, -1); resetFormat(); return *this;  }
	sttfont_formatted_text& operator << (const sttfont_format & format) 		{ activeFormat.combine(format); return *this; }
	sttfont_formatted_text& operator << (const sttfont_format_reset & reset) 	{ resetFormat(); return *this; }
	sttfont_formatted_text& operator << (const sttfont_formatted_text_item & obj) { allocatorAwareAppend(obj); return *this; }
	sttfont_formatted_text& operator << (sttfont_formatted_text_item_MS obj) 	{ allocatorAwareAppendMv(std::move(obj)); return *this; }
	sttfont_formatted_text& appendCBuff(const char * text, const uint32_t maxLen) {
		const char* p = text;
		while (*p) p++;
		uint32_t len = (p - text);
		if (len > maxLen) len = maxLen;
		append_plaintext_BUF(text, len, NULL);
		return *this;
		}


	void allocatorAwareAppend(const sttfont_formatted_text_item & obj) {
		// appends into this using this' allocator
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			sttfont_formatted_text_item tmp;
				setCustomAllocatorForTextItem(tmp);
			tmp = obj; // copy into custom allocated memory
			mItems.push_back(std::move(tmp));
		#else
			mItems.push_back(obj);
		#endif
		}
	void allocatorAwareAppendMv(sttfont_formatted_text_item_MS obj) {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			if (mItems.getCustomAllocator())
				return allocatorAwareAppend(obj);
		#else
			mItems.push_back(std::move(obj));
		#endif
		}
	void allocatorAwareAssign(const sttfont_formatted_text& other) {
		// copies other's data -> this, keeping this' allocator
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			stt::allocatorI * a = mItems.getCustomAllocator();
			if (a)
				return copyInterned(a, *this, other, false);
		#endif
		mItems = other.mItems;
		activeFormat = other.activeFormat;
		}
	void allocatorAwareAssignMv(sttfont_formatted_text_MS other) {
		// moving other -> this, keeping this' allocator
		sttfont::allocator_aware_move_or_copy(mItems, other.mItems);
		activeFormat = other.activeFormat;
		}

	static void sttr_register() {
		#ifdef STTR_ENABLED
		#define STTR_REGF_ALIAS(C,X,A,F) regField<C,decltype(&C::X),F>(&C::X,#A).setUserFlags(F)
		
		sttr::RegNamespace & R = *sttr::getGlobalNamespace();
		R.beginClass<sttfont_formatted_text>("sttfont_formatted_text")
			.STTR_REGF(sttfont_formatted_text,mItems,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_formatted_text,activeFormat,STTR_JSON_ENABLED)
			.STTR_REGF(sttfont_formatted_text,swap,0)
			.STTR_REGF(sttfont_formatted_text,copy,0)
			.STTR_REGF(sttfont_formatted_text,size,0)
			.STTR_REGF(sttfont_formatted_text,length,0)
			.STTR_REGF(sttfont_formatted_text,isEmpty,0)
			.STTR_REGF(sttfont_formatted_text,getString,0)
			.STTR_REGF(sttfont_formatted_text,getTtyString,0)
			.STTR_REGF(sttfont_formatted_text,getStringTruncated,0)
			.STTR_REGF(sttfont_formatted_text,append_luasafe,0)
			.STTR_REGF(sttfont_formatted_text,append_plaintext_str,0)
			.STTR_REGF(sttfont_formatted_text,clear,0)
			.STTR_REGF(sttfont_formatted_text,overrideColour,0)
			.STTR_REGF(sttfont_formatted_text,consolidateSegments,0)
			.STTR_REGF(sttfont_formatted_text,back,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,getIndexAt_luasafe,getIndexAt,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,utf8_charsizeAt_luasafe,utf8_charsizeAt,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,insert_luasafe,insert,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,remove_luasafe,remove,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,substr_luasafe,substr,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,extract_luasafe,extract,0)
			.STTR_REGF_ALIAS(sttfont_formatted_text,tokenise_luasafe,tokenise,0)
			
			
		.endClass();
		#undef STTR_REGF_ALIAS
		#endif
		}
	STTFONT_STTR_CLASS_SIG_NON_POLY(sttfont_formatted_text)
	
	void setAllocator(stt::allocatorI * alloc) {
		// For use with stt-stl
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			mItems.setAllocator(alloc);
		#endif
		}
		
	void setCustomAllocatorForTextItem(sttfont_formatted_text_item & ti) {
		// Internal function that propgoates mItem.sso.d.store.mAllocator to any text its
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			stt::allocatorI* alloc = mItems.getCustomAllocator();
			if (alloc)
				ti.setAllocator(alloc);
		#endif
		}
	
	static void copyInterned (stt::allocatorI* alloc, sttfont_formatted_text & dst, const sttfont_formatted_text & src, const bool internStrings) {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			// copies to an empty container which will use allocator alloc
			// strings within this item can be optionally marked as interned
			assert(dst.isEmpty());
			assert(alloc);
			
			dst.mItems.setAllocator(alloc);
			uint32_t nItems = src.mItems.size();
			dst.mItems.resize(nItems);
			for (uint32_t i = 0; i < nItems; ++i) {
				dst.mItems[i].text.setAllocator(alloc);
				dst.mItems[i].text = src.mItems[i].text;
				if (internStrings)
					dst.mItems[i].text.markInterned(); // do not deallocate through destructor
				dst.mItems[i].format = src.mItems[i].format;
				}
			dst.activeFormat = src.activeFormat;
		#else
			// copy
			dst = src;
		#endif
		}	
		
	void markInterned() {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
		// marks all elements as interned
			uint32_t nItems = mItems.size();
			for (uint32_t i = 0; i < nItems; ++i)
				mItems[i].text.markInterned();
			mItems.markInterned();
		#endif
		}
		
	sttfont_formatted_text copy() const {
		// Explicit copy - named function
		sttfont_formatted_text r = *this;
		return r;
		}
		
	void swap(sttfont_formatted_text & other) {
		other.mItems.swap(mItems);
		other.activeFormat.swap(activeFormat);
		}
		
	size_t size() const {
		/// Combined length of all the segments
		size_t workingLen = 0;
		for (unsigned int  i = 0; i < mItems.size(); ++i ) {
			workingLen += mItems[i].text.size();
			}
		return workingLen;
		}
	size_t length() const { return size(); }
	
	bool isEmpty() const {
		/// Returns true if there are no segments, or there are only empty segments
		/// Ie, returns true if this contains no characters
		if (!mItems.size()) return true;
		//if (mItems.size() == 1) return !mItems[0].text.size();
		for (sttfont_formatted_text_item item : mItems)
			if (item.text.size()) return false;
		return true; // none of the elements have text
		}
		
	SSF_STRING getString() const {
		/// Returns a plain unformatted string of all the segments stitched together
		SSF_STRING r;
		r.reserve(size());
		for (unsigned int  i = 0; i < mItems.size(); ++i ) {
			r += mItems[i].text;
			}
		return r;
		}
		
	SSF_STRING getTtyString() const {
		/// Returns a string of all the segments linked together with Tty format codes applied
		SSF_STRING r;
		r.reserve(size() + mItems.size()*32);
		for (unsigned int  i = 0; i < mItems.size(); ++i ) {
			r += mItems[i].format.getTtyFormatCodeBegin();
			r += mItems[i].text;
			r += mItems[i].format.getTtyFormatCodeEnd();
			}
		return r;
		}
		
	SSF_STRING getStringTruncated(const unsigned int maxLen) const {
		/// Returns a plain unformatted string of all the segments stitched together, cut to max len
		SSF_STRING r;
		r.reserve(size());
		for (unsigned int  i = 0; i < mItems.size(); ++i ) {
			r += mItems[i].text;
			if (r.size() > maxLen) {
				if (maxLen > 3)
					return r.substr(0, maxLen-3)+"...";
				return r.substr(0, maxLen);
				}
			}
		return r;
		}
		
	void append_luasafe(const sttfont_formatted_text & obj) {
		/// Appends a sttfont_formatted_text to this
		if (obj.mItems.size() == 1 && mItems.size()) {
			if (mItems[mItems.size()-1].format == obj.mItems[0].format) {
				mItems[mItems.size()-1].text += obj.mItems[0].text;
				return;
				}
			}
		activeFormat = obj.activeFormat;
		#if SSF_STT_STL_ALLOCATOR_ENABLED
		stt::allocatorI* a = mItems.getCustomAllocator();
		if (a) {
			uint32_t szInit = mItems.size();
			uint32_t otherSz = obj.mItems.size();
			if (!otherSz) return;
			mItems.resize(szInit + otherSz);
			for (uint32_t i = 0; i < otherSz; ++i) {
				mItems[szInit+i].text.setAllocator(a);
				mItems[szInit+i].text = obj.mItems[i].text;
				mItems[szInit+i].format = obj.mItems[i].format;
				}
			return;
			}
		#endif
		mItems.insert(mItems.end(), obj.mItems.begin(), obj.mItems.end());
		}
	
	
	void append_plaintext_MS (SSF_STRING_MS str, const sttfont_format* fmt) {
		/// Appends a plaintext string with optional formatting
		/// if fmt is NULL then use activeFormat
		/// if fmt matches the format of the last segment then append to the last segment
		/// if not create a new segment with the specified text and format
		if (!fmt)
			return append_plaintext_MS(std::move(str), &activeFormat);
		const uint32_t sz = mItems.size();
		if (sz) {
			if (mItems[sz-1].format == *fmt) {
				mItems[sz-1].text.append(str);
				return;
				}
			}
		sttfont_formatted_text_item ti;
			setCustomAllocatorForTextItem(ti);
		ti.text = std::move(str);
		ti.format = *fmt;
		mItems.push_back(std::move(ti));
		}
		
	void append_plaintext_BUF(const char * str, const uint32_t len, const sttfont_format* fmt) {
		if (!fmt)
			return append_plaintext_BUF(str, len, &activeFormat);
		const uint32_t sz = mItems.size();
		if (sz) {
			if (mItems[sz-1].format == *fmt) {
				mItems[sz-1].text.append(str, len);
				return;
				}
			}
		sttfont_formatted_text_item ti;
			setCustomAllocatorForTextItem(ti);
		ti.text.append(str, len);
		ti.format = *fmt;
		#if SSF_STT_STL_ALLOCATOR_ENABLED
		// for debugging spurrious copies
		//	stt::stt_dbg_log("append_plaintext_BUF, allocators: %p %p, [%s]", mItems.getCustomAllocator(), ti.text.getCustomAllocator(), str);
		//	if (strcmp("Render Thread", str) == 0 && !mItems.getCustomAllocator())
		//		abort();
		#endif
		
		mItems.push_back(std::move(ti));
		}
		
	inline void append_plaintext (const char * str, const uint32_t len, const sttfont_format* fmt) {
		append_plaintext_BUF(str,len, fmt);
		}
	
	inline void append_plaintext_str(const SSF_STRING & str, const sttfont_format* fmt) {
		append_plaintext_BUF(str.data(), str.size(), fmt);
		}
	
	inline void append(const sttfont_formatted_text & obj) { return append_luasafe(obj); }
	
	void append(sttfont_formatted_text_MS obj) {
		#if SSF_STT_STL_ALLOCATOR_ENABLED
			if (mItems.getCustomAllocator()) {
				return append_luasafe(obj); //copy into allocator
				}
		#endif
		if (obj.mItems.size() == 1 && mItems.size()) {
			if (mItems[mItems.size()-1].format == obj.mItems[0].format) {
				mItems[mItems.size()-1].text += std::move(obj.mItems[0].text);
				return;
				}
			}
		mItems.insert(mItems.end(), std::make_move_iterator(obj.mItems.begin()), std::make_move_iterator(obj.mItems.end()));
		activeFormat = obj.activeFormat;
		}
		
	void clear() {
		*this = sttfont_formatted_text();
		}

	void overrideColour_worker(const sttfont_format & fmt, const bool force) {
		for (sttfont_formatted_text_item & sfti : mItems) {
			if (force || !(sfti.format.flags & sttfont_format::FORMAT_FLAGS_COLOUR_SET)) {
				uint8_t nfmt  = fmt.format | sfti.format.format;
				uint8_t nflg  = fmt.flags;
				sfti.format = fmt;
				sfti.format.format = nfmt;
				sfti.format.flags  = nflg;
				}
			}
		}
		
	void overrideColour(const sttfont_format & fmt) {
		/// If any pieces do not have their colour set, then override the default colour to @fmt's colour
		overrideColour_worker(fmt, false);
		}
		
	void forceOverrideColour(const sttfont_format & fmt) {
		/// Force override colour in all segments
		overrideColour_worker(fmt, true);
		}
		
	void consolidateSegments() {
		/// "Cleans" up this object by merging adjacent items if they have
		/// the same format, and removes empty segments
		
		// Strip empty segments
		for (unsigned int  i = mItems.size() - 1; i < mItems.size(); --i ) {
			if (!mItems[i].text.size())
				mItems.erase(mItems.begin() + i + 1);
			}
		size_t szStart;
		size_t szEnd;
		do {
			szStart = mItems.size();
			consolidateSegments_worker();
			szEnd = mItems.size();
			}
		while (szEnd < szStart);
		}

protected:
	void consolidateSegments_worker() {
		/// "Cleans" up this object by merging adjacent items if they have the same format
		/// Removes empty segments
		for (unsigned int  i = mItems.size() - 2; i < mItems.size(); --i ) {
			if (mItems[i].format == mItems[i+1].format) {
				mItems[i].text += mItems[i+1].text;
				mItems.erase(mItems.begin() + i + 1);
				}
			}
		
		}
		
public:
	
	bool back(const unsigned int num) {
		/// Removes @num bytes from the end of this
		/// Returns true if changed
		unsigned int nToRemove = num;
		for (unsigned int  i = mItems.size() - 1; i < mItems.size(); --i ) {
			if ( mItems[i].text.size() <= nToRemove) {
				nToRemove -= mItems[i].text.size();
				mItems.erase(mItems.begin() + i);
				if (nToRemove == 0 || i == 0) {
					return true;
					}
				}
			else {
				SSF_STRING& s = mItems[i].text;
				s = s.erase(s.length()-nToRemove);
				return true;
				}
			}
		return false;
		}
		
		
	sttfont_formatted_uipair getIndexAt_luasafe(const unsigned int position, sttfont_lookupHint * mHint) const {
		sttfont_formatted_uipair r;
		getIndexAt(position, r.a, r.b, mHint);
		return r;
		}
	
	void getIndexAt(const unsigned int position, unsigned int& indexOut, unsigned int& localPosOut, sttfont_lookupHint * mHint = NULL) const {
		/// Returns the segment index and position within the segment of a character position
		/// A hint can be used to prevent itterating over the whole thing
		/// Hint is updated if mHint->writeOut is true
		indexOut = -1;
		localPosOut = -1;
		
		unsigned int start = 0;		
		unsigned int workingLen = 0;
		
		if (mHint) {
			if (position >= mHint->workingLen) {
				start = mHint->index;
				workingLen = mHint->workingLen;
				}
			else {
				// Uncomment below to test for useless hints
				//std::cout << "Hint is useless!: " << position << " " << mHint->workingLen << std::endl;
				}
			}
		
		for (unsigned int  i = start; i < mItems.size(); ++i ) {
			if (mItems[i].text.size() + workingLen > position && workingLen <= position) {
				indexOut = i;
				localPosOut = position - workingLen;
				
				if (mHint) {
					if (mHint->writeOut) {
						mHint->index = i;
						mHint->workingLen = workingLen;
						}
					}
				
				return;
				}
			workingLen += mItems[i].text.size();
			}
		}
		
	sttfont_formatted_uipair utf8_charsizeAt_luasafe(const unsigned int position, sttfont_lookupHint * mHint) {
		sttfont_formatted_uipair r;
		utf8_charsizeAt(position, r.a, r.b, mHint);
		return r;
		}
		
	void utf8_charsizeAt(const unsigned int position, unsigned int & posOut, unsigned int & sizeOut, sttfont_lookupHint * mHint = NULL) {
		/// At @position, what is the character size? Returns this in @sizeOut
		/// If this is in the middle of a character, return the position of the start of the character in @posOut
		posOut = position;
		sizeOut = 0;
		
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) return; // not found
		
		// Lookup to 3 characters back and get the charSize
		for (unsigned int lookup = 0; lookup <= offset;) {
			int thisSz = sttfont_utf8::utf8_charsize(&mItems[index].text[lookup]);
			
			//std::cout << "Lookup utf8_charsizeAt " << lookup << " " << thisSz
			//		<< " char[" << mItems[index].text.substr(lookup, thisSz) << "] " << offset << std::endl;
			
			if (thisSz + lookup > offset) {				
				//std::cout << "Out! size: " << thisSz << std::endl;
				posOut = lookup + position - offset;
				sizeOut = thisSz;
				return;
				}
			if (thisSz)
				lookup += thisSz;
			else
				lookup++;
			}
		}
		
	void insert(const unsigned int position, const SSF_STRING & str, sttfont_lookupHint * mHint = NULL) {
		/// Inserts @str at character position @pos
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) { *this << str; return; } // not found, append to end
		mItems[index].text.insert(offset, str);
		}
		
	void insert(const unsigned int position, SSF_STRING_MS str, sttfont_lookupHint * mHint = NULL) {
		/// Inserts @str at character position @pos. Moving version
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) { *this << std::move(str); return; } // not found, append to end
		mItems[index].text.insert(offset, std::move(str));
		}
		
	void insert_luasafe(const unsigned int position, const sttfont_formatted_text & str, sttfont_lookupHint * mHint) {
		/// Inserts @str at character position @pos. Copying formatted text version
		if (str.mItems.size() == 0) return;
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) { append(str); return; } // not found, append to end

		if (str.mItems.size() == 1) { // Quickie - only 1 format being inserted. Do not split
			if (mItems[index].format == str.mItems[0].format) {
				mItems[index].text.insert(offset, str.mItems[0].text); return;
				}
			}
			
		sttfont_formatted_text_item after;	
			setCustomAllocatorForTextItem(after);
			after = mItems[index];
		mItems[index].text.erase(offset);
		after.text.erase(0, offset);	
		
		unsigned int strSz = str.mItems.size();
		mItems.insert(mItems.begin()+index+1, str.mItems.begin(), str.mItems.end());
		
		if (after.text.length())
			mItems.insert(mItems.begin()+index+1+strSz, std::move(after));
		}
	inline void insert(const unsigned int position, const sttfont_formatted_text & str, sttfont_lookupHint * mHint = NULL) { insert_luasafe(position, str, mHint); }
		
	void insert(const unsigned int position, sttfont_formatted_text_MS str, sttfont_lookupHint * mHint = NULL) {
		/// Inserts @str at character position @pos. Moving version
		if (str.mItems.size() == 0) return;
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) { append(std::move(str)); return; } // not found, append to end
		
		if (str.mItems.size() == 1) { // Quickie - only 1 format being inserted. Do not split
			if (mItems[index].format == str.mItems[0].format) {
				mItems[index].text.insert(offset, std::move(str.mItems[0].text)); return;
				}
			}
			
		sttfont_formatted_text_item after;	
			setCustomAllocatorForTextItem(after);
			after = mItems[index];
		mItems[index].text.erase(offset);
		after.text.erase(0, offset);	
		
		unsigned int strSz = str.mItems.size();
		mItems.insert(mItems.begin()+index+1, std::make_move_iterator(str.mItems.begin()), std::make_move_iterator(str.mItems.end()));
		
		if (after.text.length())
			mItems.insert(mItems.begin()+index+1+strSz, std::move(after));
		}
		

	void remove_luasafe(const unsigned int position, const unsigned int num, sttfont_lookupHint * mHint) {
		/// Removes @num characters after position num
		/// Note that if you're using hints that they might be invalid after removing text
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) return; // not found
		
		unsigned int numToRemove = num;
		
		for (unsigned int i = index; i < mItems.size(); ++i) {
			unsigned int nToRemove = mItems[i].text.size() - offset;
			if (nToRemove > numToRemove) nToRemove = numToRemove;
			
			if (nToRemove == mItems[i].text.size() && offset == 0) {
				mItems.erase(mItems.begin() + i);
				--i;
				return;
				}
			mItems[i].text.erase(offset, nToRemove);
			
			numToRemove -= nToRemove;
			offset = 0;
			}
			
		}
		
	inline void remove(const unsigned int position, const unsigned int num, sttfont_lookupHint * mHint = NULL) { remove_luasafe(position, num, mHint); }
	
	SSF_STRING substr(const unsigned int position, const unsigned int num, sttfont_lookupHint * mHint = NULL) const {
		/// Reads @num characters after @position. If num goes past the end of a string
		/// then returns the end of the string. Returns as a plain string
		/// To get a "formatted" substr use this->extract(position, num);
		SSF_STRING r;
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) return r; // not found
		
		unsigned int numToRemove = num;
		
		for (unsigned int i = index; i < mItems.size(); ++i) {
			unsigned int nToRemove = mItems[i].text.size() - offset;
			if (nToRemove > numToRemove) nToRemove = numToRemove;
			
			r += mItems[i].text.substr(offset, nToRemove);
			
			numToRemove -= nToRemove;
			offset = 0;
			}
		return r;
		}
	inline SSF_STRING substr_luasafe(const unsigned int position, const unsigned int num, sttfont_lookupHint * mHint) const {
		return substr(position, num, mHint);
		}
		
	sttfont_formatted_text extract(const unsigned int position, const unsigned int num, sttfont_lookupHint * mHint = NULL) const {
		/// Creates a new @sttfont_formatted_text containing the segments starting at character @position and of length @num in bytes
		/// To get a std::string substring use this->substr(position, num)
		sttfont_formatted_text r;
		
		unsigned int index, offset;
		getIndexAt(position, index, offset, mHint);
		if (index >= mItems.size()) {
			return r;
			}
			
		unsigned int numToRemove = num;
		
		for (unsigned int i = index; i < mItems.size() && numToRemove; ++i) {
			unsigned int nToRemove = mItems[i].text.size() - offset;
			if (nToRemove > numToRemove) nToRemove = numToRemove;
			
			//std::cout << "extracting: " << i << " " << " offset: " << offset << ", nToRemove: " << nToRemove << "/" << numToRemove << " " << mItems[i].text.size() << std::endl;
			
			if (nToRemove == mItems[i].text.size() && offset == 0) {
				r.mItems.push_back(mItems[i]);
				}
			else {
				sttfont_formatted_text_item sfti;
				sfti.format = mItems[i].format;
				sfti.text = mItems[i].text.substr(offset, nToRemove);
				r.mItems.push_back(std::move(sfti));
				}
			//r += mItems[i].text.substr(offset, nToRemove);
			
			numToRemove -= nToRemove;
			offset = 0;
			}
		return r;
		}
	inline sttfont_formatted_text extract_luasafe(const unsigned int position, const unsigned int num, sttfont_lookupHint * mHint) const { return extract(position, num, mHint); }
		
	void tokenise (SSF_VECTOR<sttfont_formatted_text> & arrOut, const uint32_t delimiter, const bool checkQuoteMarks = true, const uint32_t escapeChar = '\\', const bool includeDelimiterInToken = false) const {
		/// Breaks this into an array of sttfont_formatted_text objects
		/// tokenised by "delimter" (unless inbetween two `"` marks).
		/// An escape character negates the delimiter
		/// Handles UTF-8
		///
		/// Example usage - tokenise on newlines:
		///     vector<sttfont_formatted_text> output;
		///     input.tokenise(output, '\n', true, '\\');
		///
		const sttfont_formatted_text & stringIn = *this;
		
		bool open = false;
		bool escape = false;
		
		uint32_t segmentStart = 0;	// The start of the working token
		uint32_t workingPos = 0;	// The cumulative positon along the string
		uint32_t offset = 0;		// A small offset to prevent including the token character in the extracted strings
		
		uint32_t workingPosLastStart = 0;
		uint32_t siLastStart = 0;
		
		uint32_t delimiterSize = 1;
		if (delimiter > 0x007F) delimiterSize = 2;
		if (delimiter > 0x07FF) delimiterSize = 3;
		if (delimiter > 0xFFFF) delimiterSize = 4;
		
		for (size_t si = 0; si < stringIn.mItems.size(); ++si) {
			const SSF_STRING & s = stringIn.mItems[si].text;
			uint32_t seek = 0;
			const uint32_t len = s.length();
			
			while (seek < len) {
				const uint32_t seekBefore = seek;
				uint32_t uChar = sttfont_utf8::utf8_read(&s[seek], seek, len);
				
				if (escape) {
					escape = false;
					continue;
					}
			
				if (uChar == escapeChar) {
					// Add the next charcter in regardless
					escape = true;
					continue;
					}
				if (uChar != delimiter || open) {
					if (uChar != '"' || !checkQuoteMarks) {
						// No-op
						}
					else {
						open = !open;
						}
					}
				else {
					sttfont_lookupHint mHint;
						mHint.index = siLastStart;
						mHint.workingLen = workingPosLastStart;
						
					if (includeDelimiterInToken)
						workingPos+=delimiterSize;
						
					workingPosLastStart = workingPos;
					siLastStart = si;
					
					sttfont_formatted_text d = stringIn.extract(segmentStart + offset, (workingPos + seekBefore) - segmentStart - offset, &mHint);
					segmentStart = workingPos + seekBefore;
					offset = sttfont_utf8::utf8_charsize_from_codepoint(uChar); // Used to skip including the newline
					arrOut.push_back(std::move(d));
					}
				}
			workingPos += len;
			}
		
		sttfont_lookupHint mHint;
			mHint.index = siLastStart;
			mHint.workingLen = workingPosLastStart;
		sttfont_formatted_text d = stringIn.extract(segmentStart + offset, -1, &mHint);
		arrOut.push_back(std::move(d));
		}
			
	inline void tokenise_luasafe (SSF_VECTOR<sttfont_formatted_text>* arrOut, const uint32_t delimiter, const bool checkQuoteMarks, const uint32_t escapeChar, const bool includeDelimiterInToken) const {
		return tokenise(*arrOut, delimiter, checkQuoteMarks, escapeChar, includeDelimiterInToken);
		}
	};
	
