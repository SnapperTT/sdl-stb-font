// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// producerConsumerFrontend.hh
//

#ifndef LZZ_producerConsumerFrontend_hh
#define LZZ_producerConsumerFrontend_hh
/// Used for when you want to have, eg, an Update thread and a Render thread
/// 
#ifndef SSF_MUTEX
	#define SSF_MUTEX std::mutex
	#include <mutex>
#endif

typedef uint32_t pcfc_handle;
struct producer_consumer_font_cache;
#define LZZ_INLINE inline
struct pcfc_prerendered_text : public sttfont_prerendered_text
{
  pcfc_handle handle;
  producer_consumer_font_cache * owner;
  void freeTexture ();
};
class producer_consumer_font_cache : public sttfont_font_cache
{
protected:
  struct pcfc_consumer_prerendered_text : public sttfont_prerendered_text
  {
    pcfc_handle handle;
    sttfont_formatted_text text;
    pcfc_consumer_prerendered_text ();
  };
  struct pcfc_formatted_text
  {
    sttfont_formatted_text text;
    int x;
    int y;
  };
public:
  sttfont_font_cache * consumer_font_cache;
public:
  pcfc_handle nextPrerenderTokenId;
  SSF_MUTEX mMutex;
  SSF_MAP <pcfc_handle, sttfont_prerendered_text*> prerenderMap;
  SSF_VECTOR <producer_consumer_font_cache::pcfc_consumer_prerendered_text> prerenderQueueProducer;
  SSF_VECTOR <producer_consumer_font_cache::pcfc_consumer_prerendered_text> prerenderQueueTx;
  SSF_VECTOR <producer_consumer_font_cache::pcfc_consumer_prerendered_text> prerenderQueueConsumer;
  SSF_VECTOR <pcfc_handle> destroyPrerenderQueueProducer;
  SSF_VECTOR <pcfc_handle> destroyPrerenderQueueTx;
  SSF_VECTOR <pcfc_handle> destroyPrerenderQueueConsumer;
  SSF_VECTOR <producer_consumer_font_cache::pcfc_formatted_text> textProducer;
  SSF_VECTOR <producer_consumer_font_cache::pcfc_formatted_text> textTx;
  SSF_VECTOR <producer_consumer_font_cache::pcfc_formatted_text> textConsumer;
  pcfc_handle getNextPrerenderToken ();
public:
  producer_consumer_font_cache ();
  void freeStoredPrerenderedText (bool const freeTextures);
  void loadFontManagedBoth (sttfont_memory & memory, int index = 0);
  void addFontManagedBoth (sttfont_memory & memory, int index = 0);
  pcfc_handle pushText (int const x, int const y, char const * c, uint32_t const maxLen = -1, int * xOut = NULL, int * widthOut = NULL, int * heightOut = NULL);
  pcfc_handle pushText (int const x, int const y, SSF_STRING const & str, int * xOut = NULL, int * widthOut = NULL, int * heightOut = NULL);
  pcfc_handle pushText (int const x, int const y, sttfont_formatted_text const & str, int * xOut = NULL, int * widthOut = NULL, int * heightOut = NULL);
  void drawCodepoint (sttfont_glyph const * const GS, int const x, int const y, uint32_t const codepoint, sttfont_format const * const format, uint8_t const formatCode, int const kerningAdv, int & overdraw);
  void renderTextToObject (sttfont_prerendered_text * textOut, char const * c, uint32_t const maxLen = -1);
  void renderTextToObject (sttfont_prerendered_text * textOut, SSF_STRING const & str);
  void renderTextToObject (sttfont_prerendered_text * textOut, sttfont_formatted_text const & str);
  void destroyPrerender (pcfc_handle const handle);
protected:
  template <typename T>
  void submitWorker (SSF_VECTOR <T> & vSrc, SSF_VECTOR <T> & vDst);
public:
  void submitToConsumer ();
  void receiveFromProducer ();
  template <typename T>
  void dispatchPrerenderJobs ();
  template <typename T>
  void dispatchDestroy ();
  void dispatchSinglePrerendered (pcfc_handle const prtId, int x, int y) const;
  void dispatchSinglePrerenderedWColorMod (pcfc_handle const prtId, int x, int y, int const r, int const g, int const b, int const a) const;
  void dispatchSingleText (pcfc_handle const texId);
};
template <typename T>
void producer_consumer_font_cache::submitWorker (SSF_VECTOR <T> & vSrc, SSF_VECTOR <T> & vDst)
                                                                    {
		if (!vDst.size())
			vDst.swap(vSrc);
		else {
			vDst.insert(vDst.end(), std::make_move_iterator(vSrc.begin()), std::make_move_iterator(vSrc.end()));
			vSrc.clear();
			}
		}
template <typename T>
void producer_consumer_font_cache::dispatchPrerenderJobs ()
                                     {
		// T is the sttfont_prerendered_text subclass that is used by consumer_font_cache
		for (pcfc_consumer_prerendered_text & p2 : prerenderQueueConsumer) {
			auto itt = prerenderMap.find(p2.handle);
			if (itt != prerenderMap.end())
				abort(); // Idx reusued, this will leak memory
			T* t = SSF_NEW(T);
			consumer_font_cache->renderTextToObject(t, p2.text);
			prerenderMap[p2.handle] = t;
			}
		prerenderQueueConsumer.clear();
		}
template <typename T>
void producer_consumer_font_cache::dispatchDestroy ()
                               {
		// T is the sttfont_prerendered_text subclass that is used by consumer_font_cache
		for (const pcfc_handle idx : destroyPrerenderQueueConsumer) {
			auto itt = prerenderMap.find(idx);
			if (itt != prerenderMap.end()) {
				itt->second->freeTexture();
				SSF_DEL(itt->second);
				prerenderMap.erase(itt);
				}
			}
		}
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef SDL_STB_FONT_IMPL
#ifndef SDL_STB_FONT_IMPL_DOUBLE_GUARD_producerConsumerFrontend
#define SDL_STB_FONT_IMPL_DOUBLE_GUARD_producerConsumerFrontend
// producerConsumerFrontend.cpp
//

#define LZZ_INLINE inline
void pcfc_prerendered_text::freeTexture ()
                           {
		if (owner)
			owner->destroyPrerender(handle);
		}
producer_consumer_font_cache::pcfc_consumer_prerendered_text::pcfc_consumer_prerendered_text ()
                                                 {}
pcfc_handle producer_consumer_font_cache::getNextPrerenderToken ()
                                            {
		return nextPrerenderTokenId++;
		}
producer_consumer_font_cache::producer_consumer_font_cache ()
  : consumer_font_cache (NULL), nextPrerenderTokenId (0)
                                                                                            {}
void producer_consumer_font_cache::freeStoredPrerenderedText (bool const freeTextures)
                                                                {
		for (auto ppair : prerenderMap) {
			sttfont_prerendered_text* prt = ppair.second;
			if (!prt) continue;
			if (freeTextures) {
				prt->freeTexture();
				}
			SSF_DEL(prt);
			prerenderMap.clear();
			}
		}
void producer_consumer_font_cache::loadFontManagedBoth (sttfont_memory & memory, int index)
                                                                          {
		sttfont_memory memory2;
		memory.cloneTo(memory2);
		
		consumer_font_cache->syncFrom(*this);
		consumer_font_cache->loadFontManaged(memory2, index);
		this->syncFrom(*consumer_font_cache);
		this->loadFontManaged(memory, index);
		}
void producer_consumer_font_cache::addFontManagedBoth (sttfont_memory & memory, int index)
                                                                         {
		sttfont_memory memory2;
		memory.cloneTo(memory2);
		
		consumer_font_cache->syncFrom(*this);
		consumer_font_cache->addFontManaged(memory2, index);
		this->syncFrom(*consumer_font_cache);
		this->addFontManaged(memory, index);
		}
pcfc_handle producer_consumer_font_cache::pushText (int const x, int const y, char const * c, uint32_t const maxLen, int * xOut, int * widthOut, int * heightOut)
                                                                                                                                                                 {
		sttfont_formatted_text tmp(c, maxLen);
		return pushText(x, y, tmp, xOut, widthOut, heightOut);
		}
pcfc_handle producer_consumer_font_cache::pushText (int const x, int const y, SSF_STRING const & str, int * xOut, int * widthOut, int * heightOut)
                                                                                                                                              {
		sttfont_formatted_text tmp(str);
		return pushText(x, y, tmp, xOut, widthOut, heightOut);
		}
pcfc_handle producer_consumer_font_cache::pushText (int const x, int const y, sttfont_formatted_text const & str, int * xOut, int * widthOut, int * heightOut)
                                                                                                                                                          {
		if (xOut || widthOut || heightOut) {
			int xx = processFormatted(str, x, y, false, widthOut, heightOut);
			if (xOut) *xOut = xx;
			}
		pcfc_formatted_text p;
		p.text = str;
		p.x = x;
		p.y = y;
		textProducer.push_back(std::move(p));
		return textProducer.size() - 1; 
		}
void producer_consumer_font_cache::drawCodepoint (sttfont_glyph const * const GS, int const x, int const y, uint32_t const codepoint, sttfont_format const * const format, uint8_t const formatCode, int const kerningAdv, int & overdraw)
                                                                                                                                                                                                                     {
		// This function should never be called for this frontend. Use pushText instead of drawText
		abort();
		}
void producer_consumer_font_cache::renderTextToObject (sttfont_prerendered_text * textOut, char const * c, uint32_t const maxLen)
                                                                                                                 {
		sttfont_formatted_text tmp(c, maxLen);
		renderTextToObject (textOut, tmp);
		}
void producer_consumer_font_cache::renderTextToObject (sttfont_prerendered_text * textOut, SSF_STRING const & str)
                                                                                             {
		sttfont_formatted_text tmp(str);
		renderTextToObject (textOut, tmp);
		}
void producer_consumer_font_cache::renderTextToObject (sttfont_prerendered_text * textOut, sttfont_formatted_text const & str)
                                                                                                         {
		pcfc_prerendered_text* p = (pcfc_prerendered_text*) textOut;
		getTextSize(textOut->width, textOut->height, str);
		p->handle = getNextPrerenderToken();
		p->owner = this;
		
		pcfc_consumer_prerendered_text p2;
		p2.width = p->width;
		p2.height = p->height;
		p2.handle = p->handle;
		p2.text = str;
		
		prerenderQueueProducer.push_back(p2);
		}
void producer_consumer_font_cache::destroyPrerender (pcfc_handle const handle)
                                                        {
		destroyPrerenderQueueProducer.push_back(handle);
		}
void producer_consumer_font_cache::submitToConsumer ()
                                {
		if (!(prerenderQueueProducer.size() || destroyPrerenderQueueProducer.size() || textProducer.size())) return; // nothing to submit
		mMutex.lock();
		submitWorker(prerenderQueueProducer, prerenderQueueTx);
		submitWorker(destroyPrerenderQueueProducer, destroyPrerenderQueueTx);
		submitWorker(textProducer, textTx);
		mMutex.unlock();
		}
void producer_consumer_font_cache::receiveFromProducer ()
                                   {
		textConsumer.clear();
		mMutex.lock();
		prerenderQueueConsumer.swap(prerenderQueueTx);
		destroyPrerenderQueueConsumer.swap(destroyPrerenderQueueTx);
		textConsumer.swap(textTx);
		mMutex.unlock();
		}
void producer_consumer_font_cache::dispatchSinglePrerendered (pcfc_handle const prtId, int x, int y) const
                                                                                    {
		auto itt = prerenderMap.find(prtId);
		if (itt != prerenderMap.end()) {
			itt->second->draw(x, y);
			}
		}
void producer_consumer_font_cache::dispatchSinglePrerenderedWColorMod (pcfc_handle const prtId, int x, int y, int const r, int const g, int const b, int const a) const
                                                                                                                                                 {
		auto itt = prerenderMap.find(prtId);
		if (itt != prerenderMap.end()) {
			itt->second->drawWithColorMod(x, y, r, g, b, a);
			}
		}
void producer_consumer_font_cache::dispatchSingleText (pcfc_handle const texId)
                                                         {
		if (texId < textConsumer.size() && texId >= 0) {
			pcfc_formatted_text & pcf = textConsumer[texId];
			consumer_font_cache->drawText(pcf.x, pcf.y, pcf.text);
			}
		}
#undef LZZ_INLINE
#endif //SDL_STB_FONT_IMPL_DOUBLE_GUARD_producerConsumerFrontend
#endif //SDL_STB_FONT_IMPL_IMPL
